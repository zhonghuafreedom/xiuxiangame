<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, orientation=landscape">
    <title>ä¿®ä»™ä¹‹è·¯ - è¬åŠæ­¸å®—</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
        }
        
        body {
            background: #1a1a2e;
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        /* å¼·åˆ¶æ©«å±æç¤º */
        .rotate-screen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #1a1a2e;
            z-index: 9999;
            color: white;
            font-size: 20px;
            text-align: center;
            padding: 20px;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .rotate-icon {
            font-size: 60px;
            animation: rotate 2s infinite;
            margin-bottom: 20px;
        }
        
        @keyframes rotate {
            0% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
            100% { transform: rotate(90deg); }
        }
        
        @media screen and (orientation: portrait) {
            .rotate-screen {
                display: flex;
            }
            #gameContainer {
                display: none;
            }
        }
        
        #gameContainer {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a2e;
        }
        
        /* é è¼‰åœ–ç‰‡ - éš±è—ä½†ç¢ºä¿è¼‰å…¥ */
        .sprite-preload {
            position: absolute;
            left: -9999px;
            top: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
        }
        
        /* é ‚éƒ¨ç‹€æ…‹æ¬„ - é©é…æ©«å± */
        .top-status {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), rgba(0,0,0,0.3));
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            z-index: 100;
        }
        
        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .realm-badge {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #333;
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 11px;
            font-weight: bold;
        }
        
        .lingshi-display {
            background: linear-gradient(135deg, #9c27b0, #e91e63);
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 11px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .resource-bars {
            flex: 1;
            max-width: 180px;
        }
        
        .mini-bar {
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
            margin: 2px 0;
            position: relative;
        }
        
        .mini-bar-fill {
            height: 100%;
            transition: width 0.3s;
        }
        
        .mana-fill { background: linear-gradient(90deg, #2196f3, #00bcd4); }
        .spiritual-fill { background: linear-gradient(90deg, #9c27b0, #e91e63); }
        
        /* è™›æ“¬æ–æ¡¿ */
        .joystick-container {
            position: fixed;
            left: 20px;
            bottom: 20px;
            width: 120px;
            height: 120px;
            z-index: 200;
        }
        
        .joystick-base {
            position: absolute;
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, rgba(255,255,255,0.1), rgba(255,255,255,0.02));
            border: 3px solid rgba(255,255,255,0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .joystick-stick {
            position: absolute;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, #4a90e2, #357abd);
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(74, 144, 226, 0.5);
            transition: none;
            cursor: grab;
        }
        
        .joystick-stick.active {
            cursor: grabbing;
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.8);
        }
        
        /* å³å´æŠ€èƒ½æŒ‰éˆ• - é©é…æ©«å± */
        .skill-buttons {
            position: fixed;
            right: 20px;
            bottom: 20px;
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(2, 60px);
            gap: 10px;
            z-index: 200;
        }
        
        .skill-btn {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #2a2a3e, #3a3a4e);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .skill-btn.attack {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            border-color: #e74c3c;
        }
        
        .skill-btn.defense {
            background: linear-gradient(135deg, #3498db, #2980b9);
            border-color: #3498db;
        }
        
        .skill-btn.special {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            border-color: #f39c12;
        }
        
        .skill-btn.magic {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            border-color: #9b59b6;
            box-shadow: 0 0 10px rgba(155, 89, 182, 0.5);
        }
        
        .skill-btn:active {
            transform: scale(0.92);
        }
        
        .skill-icon {
            font-size: 20px;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.5));
        }
        
        .skill-name {
            font-size: 9px;
            color: rgba(255,255,255,0.9);
            font-weight: 500;
        }
        
        .cooldown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            border-radius: 10px;
            display: none;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 16px;
            font-weight: bold;
        }
        
        .cooldown-overlay.active {
            display: flex;
        }
        
        /* æ³•è¡“èœå–® - é©é…æ©«å± */
        .spell-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 80%;
            max-width: 600px;
            max-height: 90vh;
            background: linear-gradient(135deg, #1e1e2e, #2d2d3f);
            border: 3px solid #9b59b6;
            border-radius: 20px;
            padding: 15px;
            z-index: 1001;
            transition: transform 0.3s ease;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(155, 89, 182, 0.8);
        }
        
        .spell-menu.show {
            transform: translate(-50%, -50%) scale(1);
        }
        
        .spell-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(155, 89, 182, 0.3);
        }
        
        .spell-title {
            font-size: 20px;
            color: #ffd700;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .close-spell-menu {
            width: 30px;
            height: 30px;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 50%;
            color: white;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        
        .close-spell-menu:hover {
            background: rgba(255,255,255,0.2);
            transform: rotate(90deg);
        }
        
        .spell-item {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(155, 89, 182, 0.3);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 10px;
            transition: all 0.3s;
        }
        
        .spell-item:hover {
            background: rgba(155, 89, 182, 0.1);
            border-color: rgba(155, 89, 182, 0.5);
            transform: translateX(5px);
        }
        
        .spell-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .spell-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .spell-icon-large {
            font-size: 28px;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }
        
        .spell-details {
            flex: 1;
        }
        
        .spell-name {
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 4px;
        }
        
        .spell-level {
            display: inline-block;
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #333;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 10px;
            font-weight: bold;
        }
        
        .spell-upgrade-btn {
            background: linear-gradient(135deg, #27ae60, #229954);
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            color: white;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 3px 10px rgba(39, 174, 96, 0.4);
        }
        
        .spell-upgrade-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.6);
        }
        
        .spell-upgrade-btn:disabled {
            background: linear-gradient(135deg, #555, #333);
            cursor: not-allowed;
            box-shadow: none;
        }
        
        .spell-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin: 10px 0;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
        }
        
        .stat-label {
            color: #aaa;
        }
        
        .stat-value {
            color: #4caf50;
            font-weight: bold;
        }
        
        .stat-value.highlight {
            color: #ffd700;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
        }
        
        .spell-description {
            font-size: 11px;
            color: #999;
            line-height: 1.3;
            margin-top: 8px;
            padding: 8px;
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
        }
        
        .upgrade-cost {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        
        .cost-label {
            font-size: 11px;
            color: #ff9800;
        }
        
        .cost-value {
            font-size: 14px;
            color: #ffd700;
            font-weight: bold;
        }
        
        /* é®ç½© */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            display: none;
            backdrop-filter: blur(5px);
        }
        
        .overlay.show {
            display: block;
        }
        
        /* æˆ°é¬¥æ—¥èªŒ - æ©«å±ä½ç½® */
        .combat-log {
            position: fixed;
            top: 50px;
            right: 10px;
            width: 180px;
            max-height: 80px;
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            padding: 8px;
            overflow-y: auto;
            z-index: 50;
            font-size: 10px;
        }
        
        /* PCæ§åˆ¶æç¤º */
        .pc-controls {
            position: fixed;
            top: 50px;
            left: 10px;
            background: rgba(0,0,0,0.5);
            padding: 8px;
            border-radius: 8px;
            font-size: 10px;
            color: #999;
            z-index: 50;
        }
        
        /* åº•éƒ¨åŠŸèƒ½æŒ‰éˆ• */
        .bottom-function-buttons {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 150;
        }
        
        .function-btn {
            width: 55px;
            height: 55px;
            background: linear-gradient(135deg, #ff9800, #f57c00);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 10px rgba(255, 152, 0, 0.4);
        }
        
        .function-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 152, 0, 0.6);
        }
        
        .function-btn:active {
            transform: scale(0.95);
        }
        
        .function-icon {
            font-size: 20px;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.5));
        }
        
        .function-name {
            font-size: 9px;
            color: white;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        /* é€šç”¨ç³»çµ±é¢æ¿æ¨£å¼ */
        .system-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 85%;
            max-width: 700px;
            height: 85vh;
            max-height: 500px;
            background: linear-gradient(135deg, #2a2a3e, #1a1a2e);
            border: 3px solid;
            border-radius: 20px;
            padding: 20px;
            z-index: 1001;
            transition: transform 0.3s ease;
            overflow-y: auto;
            display: none;
        }
        
        .system-panel.show {
            display: block;
            transform: translate(-50%, -50%) scale(1);
        }
        
        .system-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255,255,255,0.2);
        }
        
        .system-panel-title {
            font-size: 22px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .close-btn {
            width: 30px;
            height: 30px;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 50%;
            color: white;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        
        .close-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: rotate(90deg);
        }
        
        /* å„²ç‰©è¢‹ç³»çµ± */
        #storagePanel {
            border-color: #9c27b0;
            box-shadow: 0 0 30px rgba(156, 39, 176, 0.5);
        }
        
        #storagePanel .system-panel-title {
            color: #e1bee7;
        }
        
        .storage-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 5px;
            margin-bottom: 15px;
        }
        
        .storage-slot {
            aspect-ratio: 1;
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }
        
        .storage-slot:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.3);
        }
        
        .item-icon {
            font-size: 24px;
        }
        
        .item-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: rgba(0,0,0,0.7);
            color: #ffd700;
            font-size: 10px;
            padding: 1px 3px;
            border-radius: 3px;
        }
        
        /* ç…‰ä¸¹ç³»çµ± */
        #alchemyPanel {
            border-color: #4caf50;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.5);
        }
        
        #alchemyPanel .system-panel-title {
            color: #a5d6a7;
        }
        
        .alchemy-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .recipe-list {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 10px;
            max-height: 350px;
            overflow-y: auto;
        }
        
        .recipe-item {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(76, 175, 80, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .recipe-item:hover {
            background: rgba(76, 175, 80, 0.1);
            border-color: rgba(76, 175, 80, 0.5);
        }
        
        .recipe-name {
            font-weight: bold;
            color: #4caf50;
            margin-bottom: 3px;
        }
        
        .recipe-effect {
            font-size: 11px;
            color: #999;
        }
        
        .alchemy-workspace {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .material-slots {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        
        .material-slot {
            aspect-ratio: 1;
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }
        
        .refine-btn {
            background: linear-gradient(135deg, #4caf50, #388e3c);
            border: none;
            padding: 12px;
            border-radius: 25px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 3px 10px rgba(76, 175, 80, 0.4);
        }
        
        .refine-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.6);
        }
        
        .refine-btn:disabled {
            background: linear-gradient(135deg, #555, #333);
            cursor: not-allowed;
        }
        
        /* é›é€ ç³»çµ± */
        #forgePanel {
            border-color: #ff5722;
            box-shadow: 0 0 30px rgba(255, 87, 34, 0.5);
        }
        
        #forgePanel .system-panel-title {
            color: #ffab91;
        }
        
        .forge-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .equipment-list {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 10px;
            max-height: 350px;
            overflow-y: auto;
        }
        
        .equipment-item {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255, 87, 34, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .equipment-item:hover {
            background: rgba(255, 87, 34, 0.1);
            border-color: rgba(255, 87, 34, 0.5);
        }
        
        .equipment-name {
            font-weight: bold;
            color: #ff5722;
            margin-bottom: 3px;
        }
        
        .equipment-stats {
            font-size: 11px;
            color: #999;
        }
        
        .forge-workspace {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .forge-btn {
            background: linear-gradient(135deg, #ff5722, #e64a19);
            border: none;
            padding: 12px;
            border-radius: 25px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 3px 10px rgba(255, 87, 34, 0.4);
        }
        
        .forge-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 87, 34, 0.6);
        }
        
        /* æ´åºœç³»çµ± */
        #cavePanel {
            border-color: #2196f3;
            box-shadow: 0 0 30px rgba(33, 150, 243, 0.5);
        }
        
        #cavePanel .system-panel-title {
            color: #90caf9;
        }
        
        .cave-content {
            display: grid;
            grid-template-rows: auto 1fr;
            gap: 15px;
            height: 100%;
        }
        
        .cave-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        
        .cave-stat-card {
            background: rgba(33, 150, 243, 0.1);
            border: 2px solid rgba(33, 150, 243, 0.3);
            border-radius: 10px;
            padding: 10px;
            text-align: center;
        }
        
        .cave-stat-label {
            font-size: 11px;
            color: #90caf9;
            margin-bottom: 5px;
        }
        
        .cave-stat-value {
            font-size: 18px;
            color: white;
            font-weight: bold;
        }
        
        .cave-rooms {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .cave-room {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(33, 150, 243, 0.3);
            border-radius: 10px;
            padding: 10px;
            transition: all 0.2s;
        }
        
        .cave-room:hover {
            background: rgba(33, 150, 243, 0.1);
            border-color: rgba(33, 150, 243, 0.5);
        }
        
        .room-name {
            font-weight: bold;
            color: #2196f3;
            margin-bottom: 5px;
        }
        
        .room-level {
            font-size: 11px;
            color: #ffd700;
        }
        
        .room-effect {
            font-size: 10px;
            color: #999;
            margin-top: 5px;
        }
        
        .upgrade-room-btn {
            background: linear-gradient(135deg, #2196f3, #1976d2);
            border: none;
            padding: 6px 12px;
            border-radius: 15px;
            color: white;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 8px;
            transition: all 0.2s;
        }
        
        .upgrade-room-btn:hover {
            transform: translateY(-1px);
        }
        
        @media (max-width: 768px) {
            .pc-controls {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- æ—‹è½‰å±å¹•æç¤º -->
    <div class="rotate-screen">
        <div class="rotate-icon">ğŸ“±</div>
        <div>è«‹æ—‹è½‰æ‚¨çš„è¨­å‚™è‡³æ©«å±æ¨¡å¼</div>
        <div style="font-size: 14px; margin-top: 10px; color: #999;">ç²å¾—æœ€ä½³éŠæˆ²é«”é©—</div>
    </div>
    
    <!-- é è¼‰ç²¾éˆåœ– -->
    <div class="sprite-preload">
        <!-- è§’è‰²ç²¾éˆåœ– -->
        <img id="spriteMeditate" src="character_meditate.png" alt="">
        
        <!-- åœ°åœ–åœ–å¡Š -->
        <img id="tileGrass" src="grass.png" alt="">
        <img id="tileWater" src="water.png" alt="">
        <img id="tileSand" src="sand.png" alt="">
        <img id="tileMountain" src="mountain.png" alt="">
        <img id="tileRoad" src="road.png" alt="">
        <img id="tileForest" src="forest_floor.png" alt="">
        <img id="tileFlowers" src="flowers.png" alt="">
        <img id="tileRock" src="rock.png" alt="">
        <img id="tileTree" src="tree.png" alt="">
        <img id="tileHouse" src="house.png" alt="">
        
        <!-- æ€ªç‰©ç²¾éˆåœ– -->
        <img id="monsterWolf" src="monster_wolf.png" alt="">
        <img id="monsterFox" src="monster_fox.png" alt="">
        <img id="monsterMountain" src="monster_mountain.png" alt="">
        <img id="monsterSpirit" src="monster_spirit.png" alt="">
        <img id="monsterSpider" src="monster_spider.png" alt="">
        <img id="monsterGhostfire" src="monster_ghostfire.png" alt="">
    </div>
    
    <!-- éŸ³é »å…ƒç´  -->
    <audio id="bgmLogin" src="bgm_login.mp3" loop></audio>
    <audio id="bgmMain" src="bgm_main.mp3" loop></audio>
    <audio id="clickSound" src="click.mp3"></audio>
    <audio id="sfxSwordHit" src="./sword_hit.mp3"></audio>
    
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <!-- é ‚éƒ¨ç‹€æ…‹æ¬„ -->
        <div class="top-status">
            <div class="player-info">
                <div class="realm-badge" id="realmBadge">ç…‰æ°£æœŸä¸€å±¤</div>
                <div class="lingshi-display">
                    ğŸ’ <span id="lingshiAmount">1000</span>
                </div>
            </div>
            <div class="resource-bars">
                <div class="mini-bar">
                    <div class="mini-bar-fill mana-fill" id="manaBar" style="width:100%"></div>
                </div>
                <div class="mini-bar">
                    <div class="mini-bar-fill spiritual-fill" id="spiritualBar" style="width:0%"></div>
                </div>
            </div>
        </div>
        
        <!-- æˆ°é¬¥æ—¥èªŒ -->
        <div class="combat-log" id="combatLog"></div>
        
        <!-- PCæ§åˆ¶æç¤º -->
        <div class="pc-controls">
            WASD/æ–¹å‘éµ: ç§»å‹•<br>
            æ•¸å­—éµ1-6: æŠ€èƒ½<br>
            æ»‘é¼ æ‹–æ›³æ–æ¡¿ç§»å‹•
        </div>
        
        <!-- è™›æ“¬æ–æ¡¿ -->
        <div class="joystick-container" id="joystickContainer">
            <div class="joystick-base">
                <div class="joystick-stick" id="joystickStick"></div>
            </div>
        </div>
        
        <!-- å³å´æŠ€èƒ½æŒ‰éˆ• -->
        <div class="skill-buttons">
            <div class="skill-btn attack" data-action="sword">
                <span class="skill-icon">âš”ï¸</span>
                <span class="skill-name">é£›åŠ</span>
                <div class="cooldown-overlay" data-skill="sword"></div>
            </div>
            <div class="skill-btn defense" data-action="shield">
                <span class="skill-icon">ğŸ›¡ï¸</span>
                <span class="skill-name">è­·ç›¾</span>
                <div class="cooldown-overlay" data-skill="shield"></div>
            </div>
            <div class="skill-btn special" data-action="thunder">
                <span class="skill-icon">â›ˆï¸</span>
                <span class="skill-name">é›·æ³•</span>
                <div class="cooldown-overlay" data-skill="thunder"></div>
            </div>
            <div class="skill-btn" data-action="meditate">
                <span class="skill-icon">ğŸ§˜</span>
                <span class="skill-name">æ‰“å</span>
            </div>
            <div class="skill-btn" data-action="breakthrough">
                <span class="skill-icon">âš¡</span>
                <span class="skill-name">çªç ´</span>
            </div>
            <div class="skill-btn magic" data-action="openSpellMenu">
                <span class="skill-icon">ğŸ“œ</span>
                <span class="skill-name">æ³•è¡“</span>
            </div>
        </div>
        
        <!-- åº•éƒ¨åŠŸèƒ½æŒ‰éˆ• -->
        <div class="bottom-function-buttons">
            <div class="function-btn" data-action="openStorage">
                <span class="function-icon">ğŸ’</span>
                <span class="function-name">å„²ç‰©è¢‹</span>
            </div>
            <div class="function-btn" data-action="openAlchemy">
                <span class="function-icon">ğŸ§ª</span>
                <span class="function-name">ç…‰ä¸¹</span>
            </div>
            <div class="function-btn" data-action="openForge">
                <span class="function-icon">âš’ï¸</span>
                <span class="function-name">é›é€ </span>
            </div>
            <div class="function-btn" data-action="openCave">
                <span class="function-icon">ğŸ </span>
                <span class="function-name">æ´åºœ</span>
            </div>
            <div class="function-btn" data-action="spawnMonsters" style="background: linear-gradient(135deg, #e74c3c, #c0392b);">
                <span class="function-icon">ğŸ‘¹</span>
                <span class="function-name">å¬å–šå¦–ç¸</span>
            </div>
            <div class="function-btn" data-action="toggleMusic" style="background: linear-gradient(135deg, #3498db, #2980b9);">
                <span class="function-icon">ğŸµ</span>
                <span class="function-name">éŸ³æ¨‚</span>
            </div>
        </div>
        
        <!-- æ³•è¡“èœå–® -->
        <div class="overlay" id="spellOverlay"></div>
        <div class="spell-menu" id="spellMenu">
            <div class="spell-header">
                <div class="spell-title">
                    âœ¨ æ³•è¡“ä¿®ç…‰
                </div>
                <div class="close-spell-menu" onclick="closeSpellMenu()">Ã—</div>
            </div>
            
            <div class="spell-item">
                <div class="spell-top">
                    <div class="spell-info">
                        <span class="spell-icon-large">ğŸ—¡ï¸</span>
                        <div class="spell-details">
                            <div class="spell-name">é£›åŠè¡“</div>
                            <span class="spell-level">ç­‰ç´š <span id="swordLvl">1</span> / 24</span>
                        </div>
                    </div>
                    <button class="spell-upgrade-btn" onclick="upgradeSpell('flyingSword')">å‡ç´š</button>
                </div>
                <div class="spell-stats">
                    <div class="stat-row">
                        <span class="stat-label">é£›åŠæ•¸é‡:</span>
                        <span class="stat-value highlight" id="swordCount">1</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">å–®åŠå‚·å®³:</span>
                        <span class="stat-value" id="swordDmg">30</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">æ³•åŠ›æ¶ˆè€—:</span>
                        <span class="stat-value" id="swordMana">8</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">å†·å»æ™‚é–“:</span>
                        <span class="stat-value" id="swordCD">2ç§’</span>
                    </div>
                </div>
                <div class="spell-description">
                    ç™¼å°„è¿½è¹¤é£›åŠæ”»æ“Šæ•µäººã€‚æ¯å‡ç´š2ç´šé¡å¤–å¢åŠ 1æŠŠé£›åŠï¼Œæœ€å¤šå¯é”12æŠŠé£›åŠåŒæ™‚æ”»æ“Šï¼
                </div>
                <div class="upgrade-cost">
                    <span class="cost-label">å‡ç´šéœ€è¦:</span>
                    <span class="cost-value">ğŸ’ <span id="swordCost">100</span></span>
                </div>
            </div>
            
            <div class="spell-item">
                <div class="spell-top">
                    <div class="spell-info">
                        <span class="spell-icon-large">ğŸ›¡ï¸</span>
                        <div class="spell-details">
                            <div class="spell-name">è­·ç›¾è¡“</div>
                            <span class="spell-level">ç­‰ç´š <span id="shieldLvl">1</span> / 10</span>
                        </div>
                    </div>
                    <button class="spell-upgrade-btn" onclick="upgradeSpell('shield')">å‡ç´š</button>
                </div>
                <div class="spell-stats">
                    <div class="stat-row">
                        <span class="stat-label">è­·ç›¾å€¼:</span>
                        <span class="stat-value" id="shieldAmount">50</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">å‚·å®³æ¸›å…:</span>
                        <span class="stat-value highlight" id="shieldBlock">0%</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">æŒçºŒæ™‚é–“:</span>
                        <span class="stat-value" id="shieldDuration">3ç§’</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">æ³•åŠ›æ¶ˆè€—:</span>
                        <span class="stat-value" id="shieldMana">15</span>
                    </div>
                </div>
                <div class="spell-description">
                    ç”Ÿæˆèƒ½é‡è­·ç›¾ä¿è­·è‡ªèº«ã€‚åˆå§‹æŒçºŒ3ç§’ï¼Œæ¯å‡ç´š2ç´šé¡å¤–æ¸›å…50%å‚·å®³ä¸¦å»¶é•·20%æŒçºŒæ™‚é–“ã€‚
                </div>
                <div class="upgrade-cost">
                    <span class="cost-label">å‡ç´šéœ€è¦:</span>
                    <span class="cost-value">ğŸ’ <span id="shieldCost">100</span></span>
                </div>
            </div>
            
            <div class="spell-item">
                <div class="spell-top">
                    <div class="spell-info">
                        <span class="spell-icon-large">â›ˆï¸</span>
                        <div class="spell-details">
                            <div class="spell-name">å¤©é›·è¡“</div>
                            <span class="spell-level">ç­‰ç´š <span id="thunderLvl">1</span> / 10</span>
                        </div>
                    </div>
                    <button class="spell-upgrade-btn" onclick="upgradeSpell('thunder')">å‡ç´š</button>
                </div>
                <div class="spell-stats">
                    <div class="stat-row">
                        <span class="stat-label">é›·é›»å‚·å®³:</span>
                        <span class="stat-value" id="thunderDmg">60</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">æ”»æ“Šç¯„åœ:</span>
                        <span class="stat-value" id="thunderRange">8</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">æ³•åŠ›æ¶ˆè€—:</span>
                        <span class="stat-value" id="thunderMana">30</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">å†·å»æ™‚é–“:</span>
                        <span class="stat-value" id="thunderCD">10ç§’</span>
                    </div>
                </div>
                <div class="spell-description">
                    å¬å–šå¤©é›·æ”»æ“Šç¯„åœå…§æ‰€æœ‰æ•µäººï¼Œé€ æˆå¤§é‡å‚·å®³ã€‚
                </div>
                <div class="upgrade-cost">
                    <span class="cost-label">å‡ç´šéœ€è¦:</span>
                    <span class="cost-value">ğŸ’ <span id="thunderCost">200</span></span>
                </div>
            </div>
        </div>
        
        <!-- å„²ç‰©è¢‹é¢æ¿ -->
        <div class="system-panel" id="storagePanel">
            <div class="system-panel-header">
                <div class="system-panel-title">
                    ğŸ’ å„²ç‰©è¢‹
                </div>
                <div class="close-btn" onclick="closePanel('storagePanel')">Ã—</div>
            </div>
            <div class="storage-content">
                <div class="storage-grid" id="storageGrid">
                    <!-- å‹•æ…‹ç”Ÿæˆ -->
                </div>
                <div style="color: #999; font-size: 12px; text-align: center;">
                    å®¹é‡: <span id="storageUsed">0</span> / <span id="storageMax">32</span>
                </div>
            </div>
        </div>
        
        <!-- ç…‰ä¸¹é¢æ¿ -->
        <div class="system-panel" id="alchemyPanel">
            <div class="system-panel-header">
                <div class="system-panel-title">
                    ğŸ§ª ç…‰ä¸¹çˆ
                </div>
                <div class="close-btn" onclick="closePanel('alchemyPanel')">Ã—</div>
            </div>
            <div class="alchemy-content">
                <div class="recipe-list">
                    <div class="recipe-item" onclick="selectRecipe('healing')">
                        <div class="recipe-name">å›å…ƒä¸¹</div>
                        <div class="recipe-effect">æ¢å¾©50é»æ³•åŠ›</div>
                    </div>
                    <div class="recipe-item" onclick="selectRecipe('spiritual')">
                        <div class="recipe-name">èšéˆä¸¹</div>
                        <div class="recipe-effect">å¢åŠ 30é»éˆåŠ›</div>
                    </div>
                    <div class="recipe-item" onclick="selectRecipe('breakthrough')">
                        <div class="recipe-name">ç ´å¢ƒä¸¹</div>
                        <div class="recipe-effect">çªç ´æ™‚æˆåŠŸç‡+50%</div>
                    </div>
                </div>
                <div class="alchemy-workspace">
                    <div style="text-align: center; color: #4caf50; font-size: 14px;">ç…‰ä¸¹ææ–™</div>
                    <div class="material-slots">
                        <div class="material-slot">ğŸŒ¿</div>
                        <div class="material-slot">ğŸ”®</div>
                        <div class="material-slot">ğŸ’«</div>
                    </div>
                    <button class="refine-btn" onclick="refineAlchemy()">é–‹å§‹ç…‰è£½</button>
                    <div style="text-align: center; color: #999; font-size: 11px;">
                        æˆåŠŸç‡: <span id="alchemySuccess">70%</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- é›é€ é¢æ¿ -->
        <div class="system-panel" id="forgePanel">
            <div class="system-panel-header">
                <div class="system-panel-title">
                    âš’ï¸ é›é€ å°
                </div>
                <div class="close-btn" onclick="closePanel('forgePanel')">Ã—</div>
            </div>
            <div class="forge-content">
                <div class="equipment-list">
                    <div class="equipment-item" onclick="selectEquipment('sword')">
                        <div class="equipment-name">é’é‹’åŠ</div>
                        <div class="equipment-stats">æ”»æ“ŠåŠ› +10</div>
                    </div>
                    <div class="equipment-item" onclick="selectEquipment('armor')">
                        <div class="equipment-name">ç„éµç”²</div>
                        <div class="equipment-stats">é˜²ç¦¦åŠ› +8</div>
                    </div>
                    <div class="equipment-item" onclick="selectEquipment('ring')">
                        <div class="equipment-name">èšéˆæˆ’</div>
                        <div class="equipment-stats">æ³•åŠ›ä¸Šé™ +20</div>
                    </div>
                </div>
                <div class="forge-workspace">
                    <div style="text-align: center; color: #ff5722; font-size: 14px;">é›é€ ææ–™</div>
                    <div class="material-slots">
                        <div class="material-slot">âš™ï¸</div>
                        <div class="material-slot">ğŸ”¨</div>
                        <div class="material-slot">ğŸ”¥</div>
                    </div>
                    <button class="forge-btn" onclick="forgeEquipment()">é–‹å§‹é›é€ </button>
                    <div style="text-align: center; color: #999; font-size: 11px;">
                        å“è³ª: <span id="forgeQuality">æ™®é€š</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- æ´åºœé¢æ¿ -->
        <div class="system-panel" id="cavePanel">
            <div class="system-panel-header">
                <div class="system-panel-title">
                    ğŸ  æ´åºœ
                </div>
                <div class="close-btn" onclick="closePanel('cavePanel')">Ã—</div>
            </div>
            <div class="cave-content">
                <div class="cave-stats">
                    <div class="cave-stat-card">
                        <div class="cave-stat-label">æ´åºœç­‰ç´š</div>
                        <div class="cave-stat-value" id="caveLevel">1</div>
                    </div>
                    <div class="cave-stat-card">
                        <div class="cave-stat-label">éˆæ°£æ¿ƒåº¦</div>
                        <div class="cave-stat-value" id="caveAura">100</div>
                    </div>
                    <div class="cave-stat-card">
                        <div class="cave-stat-label">æ¯æ—¥æ”¶ç›Š</div>
                        <div class="cave-stat-value"><span id="caveIncome">10</span>ğŸ’</div>
                    </div>
                </div>
                <div class="cave-rooms">
                    <div class="cave-room">
                        <div class="room-name">ä¿®ç…‰å®¤</div>
                        <div class="room-level">Lv.1</div>
                        <div class="room-effect">ä¿®ç…‰é€Ÿåº¦ +10%</div>
                        <button class="upgrade-room-btn" onclick="upgradeRoom('training')">å‡ç´š (100ğŸ’)</button>
                    </div>
                    <div class="cave-room">
                        <div class="room-name">éˆç”°</div>
                        <div class="room-level">Lv.1</div>
                        <div class="room-effect">æ¯å°æ™‚ç”¢å‡º1è‰è—¥</div>
                        <button class="upgrade-room-btn" onclick="upgradeRoom('farm')">å‡ç´š (150ğŸ’)</button>
                    </div>
                    <div class="cave-room">
                        <div class="room-name">èšéˆé™£</div>
                        <div class="room-level">Lv.1</div>
                        <div class="room-effect">æ³•åŠ›æ¢å¾© +20%</div>
                        <button class="upgrade-room-btn" onclick="upgradeRoom('array')">å‡ç´š (200ğŸ’)</button>
                    </div>
                    <div class="cave-room">
                        <div class="room-name">å¯¶åº«</div>
                        <div class="room-level">Lv.1</div>
                        <div class="room-effect">å„²ç‰©ç©ºé–“ +8</div>
                        <button class="upgrade-room-btn" onclick="upgradeRoom('treasury')">å‡ç´š (120ğŸ’)</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
class JoystickController {
    constructor(containerId, stickId, onMove) {
        this.container = document.getElementById(containerId);
        this.stick = document.getElementById(stickId);
        this.onMove = onMove;
        this.radius = 60;
        this.active = false;
        this.center = { x: 60, y: 60 };
        
        this.setupEvents();
    }
    
    setupEvents() {
        // è§¸æ‘¸äº‹ä»¶
        this.stick.addEventListener('touchstart', (e) => this.handleStart(e.touches[0]), { passive: false });
        this.stick.addEventListener('touchmove', (e) => {
            e.preventDefault();
            this.handleMove(e.touches[0]);
        }, { passive: false });
        this.stick.addEventListener('touchend', () => this.handleEnd(), { passive: false });
        
        // æ»‘é¼ äº‹ä»¶
        this.stick.addEventListener('mousedown', (e) => this.handleStart(e));
        window.addEventListener('mousemove', (e) => {
            if (this.active) this.handleMove(e);
        });
        window.addEventListener('mouseup', () => this.handleEnd());
    }
    
    handleStart(e) {
        this.active = true;
        this.stick.classList.add('active');
    }
    
    handleMove(e) {
        if (!this.active) return;
        
        const rect = this.container.getBoundingClientRect();
        const x = e.clientX - rect.left - this.center.x;
        const y = e.clientY - rect.top - this.center.y;
        
        const distance = Math.sqrt(x * x + y * y);
        const angle = Math.atan2(y, x);
        
        const limitedDistance = Math.min(distance, this.radius - 25);
        
        const newX = Math.cos(angle) * limitedDistance;
        const newY = Math.sin(angle) * limitedDistance;
        
        this.stick.style.transform = `translate(${newX}px, ${newY}px)`;
        
        // è¨ˆç®—æ–¹å‘å‘é‡
        const normalizedX = limitedDistance > 10 ? x / distance : 0;
        const normalizedY = limitedDistance > 10 ? y / distance : 0;
        
        this.onMove(normalizedX, normalizedY);
    }
    
    handleEnd() {
        if (!this.active) return;
        
        this.active = false;
        this.stick.classList.remove('active');
        this.stick.style.transform = 'translate(0, 0)';
        this.onMove(0, 0);
    }
}

class MultiSwordGame {
    constructor() {
        this.autoSaveInterval = null;
        this.lastSaveTime = Date.now();
        this.canvas = null;
        this.ctx = null;
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        
        // ç²¾éˆåœ–è¼‰å…¥ç‹€æ…‹
        this.spritesLoaded = false;
        this.sprites = {};
        
        // åœ°åœ–åœ–å¡Šè¼‰å…¥ç‹€æ…‹
        this.tilesLoaded = false;
        this.tiles = {};
        
        // æ€ªç‰©ç²¾éˆåœ–è¼‰å…¥ç‹€æ…‹
        this.monsterSpritesLoaded = false;
        this.monsterSprites = {};
        
        // éŸ³æ¨‚ç³»çµ±
        this.bgmLogin = null;
        this.bgmMain = null;
        this.clickSound = null;
        this.musicEnabled = true;
        this.currentBgm = null;
        
        // ç©å®¶æ•¸æ“š
        this.player = {
            x: 50,
            y: 50,
            worldX: 1600,
            worldY: 1600,
            mana: 100,
            maxMana: 100,
            spiritual: 0,
            maxSpiritual: 100,
            shield: 0,
            maxShield: 0,
            shieldDamageReduction: 0,
            attack: 10,
            defense: 5,
            realm: 0,
            facing: 'down',
            moving: false,
            walkFrame: 0,
            walkSpeed: 0.2,
            speed: 4,
            expression: 'normal',
            lingshi: 1000,
            spriteScale: 4
        };
        
        // æŠ€èƒ½ç³»çµ±
        this.skills = {
            flyingSword: {
                name: 'é£›åŠè¡“',
                level: 1,
                damage: 30,
                count: 1,
                maxCount: 12,
                manaCost: 8,
                cooldown: 2000,
                lastUse: 0,
                upgradeCost: 100
            },
            shield: {
                name: 'è­·ç›¾è¡“',
                level: 1,
                shieldAmount: 50,
                duration: 3000,
                damageReduction: 0,
                manaCost: 15,
                cooldown: 8000,
                lastUse: 0,
                upgradeCost: 100,
                activeUntil: 0
            },
            thunder: {
                name: 'å¤©é›·è¡“',
                level: 1,
                damage: 60,
                range: 8,
                manaCost: 30,
                cooldown: 10000,
                lastUse: 0,
                upgradeCost: 200
            }
        };
        
        // å„²ç‰©ç³»çµ±
        this.storage = {
            maxSlots: 32,
            items: []
        };
        
        // ç…‰ä¸¹ç³»çµ±
        this.alchemy = {
            recipes: {
                healing: { name: 'å›å…ƒä¸¹', materials: 3, effect: 'æ¢å¾©50æ³•åŠ›' },
                spiritual: { name: 'èšéˆä¸¹', materials: 3, effect: 'å¢åŠ 30éˆåŠ›' },
                breakthrough: { name: 'ç ´å¢ƒä¸¹', materials: 5, effect: 'çªç ´æˆåŠŸç‡+50%' }
            },
            selectedRecipe: null,
            successRate: 70
        };
        
        // é›é€ ç³»çµ±
        this.forge = {
            equipment: {
                sword: { name: 'é’é‹’åŠ', attack: 10, cost: 200 },
                armor: { name: 'ç„éµç”²', defense: 8, cost: 250 },
                ring: { name: 'èšéˆæˆ’', maxMana: 20, cost: 150 }
            },
            selectedEquipment: null
        };
        
        // æ´åºœç³»çµ±
        this.cave = {
            level: 1,
            aura: 100,
            dailyIncome: 10,
            rooms: {
                training: { name: 'ä¿®ç…‰å®¤', level: 1, effect: 0.1, upgradeCost: 100 },
                farm: { name: 'éˆç”°', level: 1, production: 1, upgradeCost: 150 },
                array: { name: 'èšéˆé™£', level: 1, manaRegen: 0.2, upgradeCost: 200 },
                treasury: { name: 'å¯¶åº«', level: 1, storageBonus: 8, upgradeCost: 120 }
            },
            lastCollectTime: Date.now()
        };
        
        // é£›åŠç³»çµ±
        this.swords = [];
        
        // ç›¸æ©Ÿ
        this.camera = { x: 0, y: 0 };
        
        // åœ°åœ–
        this.map = [];
        this.mapSize = 100;
        this.tileSize = 32;
        
        // æ€ªç‰©
        this.monsters = [];
        
        // ç²’å­æ•ˆæœ
        this.particles = [];
        
        // å‚·å®³æ•¸å­—
        this.damageNumbers = [];
        
        // è¼¸å…¥æ§åˆ¶
        this.keys = {};
        this.joystickInput = { x: 0, y: 0 };
        this.joystickController = null;
        
        this.animationId = null;
        this.lastTime = 0;
    }
    
    init() {
        console.log('åˆå§‹åŒ–éŠæˆ²ç³»çµ±...');
        
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // è¼‰å…¥ç²¾éˆåœ–
        this.loadSprites();
        
        // è¼‰å…¥åœ°åœ–åœ–å¡Š
        this.loadTiles();
        
        // è¼‰å…¥æ€ªç‰©ç²¾éˆåœ–
        this.loadMonsterSprites();
        
        // åˆå§‹åŒ–éŸ³é »ç³»çµ±
        this.initAudio();
        
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());
        
        this.generateMap();
        this.generateMonsters();
        this.setupInput();
        this.setupJoystick();
        this.initSystems();
        this.updateSpellMenu();
        this.gameLoop();
        
        this.addLog('æ­¡è¿ä¾†åˆ°ä¿®ä»™ä¸–ç•Œï¼', 'system');
        this.addLog('æç¤ºï¼šé»æ“Š"å¬å–šå¦–ç¸"æŒ‰éˆ•å¯ä»¥ç”Ÿæˆæ›´å¤šæ€ªç‰©', 'system');
        this.updateUI();
    }
    
    loadSprites() {
        const spriteNames = {
            'meditate': 'spriteMeditate'
        };
        
        let loadedCount = 0;
        const totalSprites = Object.keys(spriteNames).length;
        
        for (const [key, id] of Object.entries(spriteNames)) {
            const img = document.getElementById(id);
            if (img) {
                this.sprites[key] = img;
                loadedCount++;
                
                if (img.complete) {
                    if (loadedCount === totalSprites) {
                        this.spritesLoaded = true;
                    }
                } else {
                    img.onload = () => {
                        loadedCount++;
                        if (loadedCount === totalSprites) {
                            this.spritesLoaded = true;
                        }
                    };
                }
            }
        }
    }
    
    loadTiles() {
        const tileNames = {
            'grass': 'tileGrass',
            'water': 'tileWater',
            'sand': 'tileSand',
            'mountain': 'tileMountain',
            'road': 'tileRoad',
            'forest': 'tileForest',
            'flowers': 'tileFlowers',
            'rock': 'tileRock',
            'tree': 'tileTree',
            'house': 'tileHouse'
        };
        
        let loadedCount = 0;
        const totalTiles = Object.keys(tileNames).length;
        
        for (const [key, id] of Object.entries(tileNames)) {
            const img = document.getElementById(id);
            if (img) {
                this.tiles[key] = img;
                loadedCount++;
                
                if (img.complete) {
                    if (loadedCount === totalTiles) {
                        this.tilesLoaded = true;
                    }
                } else {
                    img.onload = () => {
                        loadedCount++;
                        if (loadedCount === totalTiles) {
                            this.tilesLoaded = true;
                        }
                    };
                }
            }
        }
    }
    
    loadMonsterSprites() {
        const monsterNames = {
            'wolf': 'monsterWolf',
            'fox': 'monsterFox',
            'mountain': 'monsterMountain',
            'spirit': 'monsterSpirit',
            'spider': 'monsterSpider',
            'ghostfire': 'monsterGhostfire'
        };
        
        let loadedCount = 0;
        const totalMonsters = Object.keys(monsterNames).length;
        
        for (const [key, id] of Object.entries(monsterNames)) {
            const img = document.getElementById(id);
            if (img) {
                this.monsterSprites[key] = img;
                loadedCount++;
                
                if (img.complete) {
                    if (loadedCount === totalMonsters) {
                        this.monsterSpritesLoaded = true;
                    }
                } else {
                    img.onload = () => {
                        loadedCount++;
                        if (loadedCount === totalMonsters) {
                            this.monsterSpritesLoaded = true;
                        }
                    };
                }
            }
        }
    }
    
    initAudio() {
        this.bgmLogin = document.getElementById('bgmLogin');
        this.bgmMain = document.getElementById('bgmMain');
        this.clickSound = document.getElementById('clickSound');
        
        // è¨­ç½®éŸ³é‡
        if (this.bgmLogin) this.bgmLogin.volume = 0.3;
        if (this.bgmMain) this.bgmMain.volume = 0.3;
        if (this.clickSound) this.clickSound.volume = 0.5;
        
        // é–‹å§‹æ’­æ”¾ä¸»èƒŒæ™¯éŸ³æ¨‚
        this.playBgm('main');
    }
    
    playBgm(type) {
        if (!this.musicEnabled) return;
        
        // åœæ­¢ç•¶å‰æ’­æ”¾çš„éŸ³æ¨‚
        if (this.currentBgm) {
            this.currentBgm.pause();
            this.currentBgm.currentTime = 0;
        }
        
        // æ’­æ”¾æ–°éŸ³æ¨‚
        if (type === 'login' && this.bgmLogin) {
            this.currentBgm = this.bgmLogin;
            this.bgmLogin.play().catch(e => console.log('ç„¡æ³•è‡ªå‹•æ’­æ”¾éŸ³æ¨‚ï¼Œéœ€è¦ç”¨æˆ¶äº’å‹•'));
        } else if (type === 'main' && this.bgmMain) {
            this.currentBgm = this.bgmMain;
            this.bgmMain.play().catch(e => console.log('ç„¡æ³•è‡ªå‹•æ’­æ”¾éŸ³æ¨‚ï¼Œéœ€è¦ç”¨æˆ¶äº’å‹•'));
        }
    }
    
    playClickSound() {
        if (this.clickSound && this.musicEnabled) {
            this.clickSound.currentTime = 0;
            this.clickSound.play().catch(e => console.log('ç„¡æ³•æ’­æ”¾éŸ³æ•ˆ'));
        }
    }
    
    toggleMusic() {
        this.musicEnabled = !this.musicEnabled;
        
        if (this.musicEnabled) {
            this.playBgm('main');
            this.addLog('èƒŒæ™¯éŸ³æ¨‚å·²é–‹å•Ÿ', 'system');
        } else {
            if (this.currentBgm) {
                this.currentBgm.pause();
            }
            this.addLog('èƒŒæ™¯éŸ³æ¨‚å·²é—œé–‰', 'system');
        }
    }
    
    spawnMonstersWave() {
        const count = 10 + Math.floor(Math.random() * 10); // ç”Ÿæˆ10-20éš»æ€ªç‰©
        let spawned = 0;
        
        for (let i = 0; i < count * 2; i++) { // å˜—è©¦æ¬¡æ•¸ç‚ºç›®æ¨™æ•¸é‡çš„2å€
            const x = Math.floor(Math.random() * this.mapSize);
            const y = Math.floor(Math.random() * this.mapSize);
            
            // æª¢æŸ¥ä½ç½®æ˜¯å¦åˆé©
            if (this.map[y] && this.map[y][x] === 'grass') {
                // æª¢æŸ¥æ˜¯å¦é›¢ç©å®¶å¤ªè¿‘
                const distToPlayer = Math.sqrt(
                    (x - this.player.x) ** 2 + 
                    (y - this.player.y) ** 2
                );
                
                if (distToPlayer > 5) { // è‡³å°‘é›¢ç©å®¶5æ ¼é 
                    const types = ['å¦–ç‹¼', 'å¦–ç‹', 'å±±å¦–', 'é‚ªéˆ', 'é­”è››', 'é¬¼ç«'];
                    const type = types[Math.floor(Math.random() * types.length)];
                    const level = Math.floor(this.player.realm / 3) + 1;
                    
                    this.monsters.push({
                        id: Date.now() + Math.random(),
                        x: x,
                        y: y,
                        hp: 50 * level,
                        maxHp: 50 * level,
                        type: type,
                        damage: 10 * level,
                        level: level,
                        patrolOriginX: x,
                        patrolOriginY: y,
                        patrolDirection: Math.floor(Math.random() * 4),
                        patrolTimer: 0,
                        patrolSpeed: 0.01 + Math.random() * 0.02,
                        patrolRange: 2 + Math.floor(Math.random() * 3),
                        moveProgress: 0,
                        targetX: x,
                        targetY: y,
                        actualX: x,
                        actualY: y
                    });
                    
                    spawned++;
                    if (spawned >= count) break;
                }
            }
        }
        
        this.addLog(`å¦–ç¸å…¥ä¾µï¼${spawned}éš»å¦–ç¸å‡ºç¾äº†ï¼`, 'system');
        
        // æ·»åŠ ç‰¹æ•ˆ
        for (let i = 0; i < 20; i++) {
            const angle = (Math.PI * 2 / 20) * i;
            this.particles.push({
                x: this.player.worldX + Math.cos(angle) * 200,
                y: this.player.worldY + Math.sin(angle) * 200,
                vx: -Math.cos(angle) * 2,
                vy: -Math.sin(angle) * 2,
                life: 60,
                maxLife: 60,
                size: 8,
                color: '#ff0000',
                type: 'spawn'
            });
        }
        
        // æ’­æ”¾é»æ“ŠéŸ³æ•ˆ
        this.playClickSound();
    }
    
    initSystems() {
        // åˆå§‹åŒ–å„²ç‰©è¢‹
        this.initStorage();
        
        // åˆå§‹åŒ–æ´åºœæ”¶ç›Šè¨ˆæ™‚å™¨
        setInterval(() => this.collectCaveIncome(), 60000); // æ¯åˆ†é˜æª¢æŸ¥ä¸€æ¬¡
    }
    
    initStorage() {
        const grid = document.getElementById('storageGrid');
        if (!grid) return;
        
        grid.innerHTML = '';
        for (let i = 0; i < this.storage.maxSlots; i++) {
            const slot = document.createElement('div');
            slot.className = 'storage-slot';
            slot.dataset.slot = i;
            
            if (this.storage.items[i]) {
                slot.innerHTML = `
                    <div class="item-icon">${this.storage.items[i].icon}</div>
                    <div class="item-count">${this.storage.items[i].count}</div>
                `;
            }
            
            grid.appendChild(slot);
        }
        
        this.updateStorageDisplay();
    }
    
    updateStorageDisplay() {
        const used = this.storage.items.filter(item => item).length;
        const usedEl = document.getElementById('storageUsed');
        const maxEl = document.getElementById('storageMax');
        if (usedEl) usedEl.textContent = used;
        if (maxEl) maxEl.textContent = this.storage.maxSlots;
    }
    
    addItemToStorage(icon, name, count = 1) {
        // æŸ¥æ‰¾æ˜¯å¦å·²æœ‰ç›¸åŒç‰©å“
        const existingItem = this.storage.items.find(item => item && item.name === name);
        if (existingItem) {
            existingItem.count += count;
        } else {
            // æ‰¾ç©ºä½
            const emptySlot = this.storage.items.findIndex(item => !item);
            if (emptySlot !== -1) {
                this.storage.items[emptySlot] = { icon, name, count };
            } else if (this.storage.items.length < this.storage.maxSlots) {
                this.storage.items.push({ icon, name, count });
            } else {
                this.addLog('å„²ç‰©è¢‹å·²æ»¿ï¼', 'system');
                return false;
            }
        }
        
        this.initStorage();
        return true;
    }
    
    openStorage() {
        document.getElementById('storagePanel').classList.add('show');
        this.initStorage();
    }
    
    openAlchemy() {
        document.getElementById('alchemyPanel').classList.add('show');
    }
    
    openForge() {
        document.getElementById('forgePanel').classList.add('show');
    }
    
    openCave() {
        document.getElementById('cavePanel').classList.add('show');
        this.updateCaveDisplay();
    }
    
    updateCaveDisplay() {
        document.getElementById('caveLevel').textContent = this.cave.level;
        document.getElementById('caveAura').textContent = this.cave.aura;
        document.getElementById('caveIncome').textContent = this.cave.dailyIncome;
    }
    
    collectCaveIncome() {
        const now = Date.now();
        const timePassed = now - this.cave.lastCollectTime;
        const hoursPassed = timePassed / (1000 * 60 * 60);
        
        if (hoursPassed >= 1) {
            const income = Math.floor(this.cave.dailyIncome * hoursPassed / 24);
            if (income > 0) {
                this.player.lingshi += income;
                this.addLog(`æ´åºœç”¢å‡º ${income} éˆçŸ³ï¼`, 'system');
                this.cave.lastCollectTime = now;
                this.updateUI();
                
                // éˆç”°ç”¢å‡º
                const herbs = Math.floor(this.cave.rooms.farm.production * hoursPassed);
                if (herbs > 0) {
                    this.addItemToStorage('ğŸŒ¿', 'éˆè‰', herbs);
                    this.addLog(`éˆç”°ç”¢å‡º ${herbs} éˆè‰ï¼`, 'system');
                }
            }
        }
    }
    
    resizeCanvas() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
    }
    
    setupJoystick() {
        this.joystickController = new JoystickController(
            'joystickContainer',
            'joystickStick',
            (x, y) => {
                this.joystickInput.x = x;
                this.joystickInput.y = y;
            }
        );
    }
    
    generateMap() {
        // ä½¿ç”¨ Perlin noise ç”Ÿæˆåœ°å½¢é«˜åº¦åœ–
        this.heightMap = [];
        this.moistureMap = [];
        
        // ç°¡åŒ–çš„å™ªè²å‡½æ•¸
        const noise = (x, y, scale) => {
            const val = Math.sin(x * scale) * Math.cos(y * scale) + 
                       Math.sin(x * scale * 2.1) * Math.cos(y * scale * 1.9) * 0.5 +
                       Math.sin(x * scale * 4.3) * Math.cos(y * scale * 3.7) * 0.25;
            return (val + 1.75) / 3.5; // æ­¸ä¸€åŒ–åˆ° 0-1
        };
        
        // ç”Ÿæˆé«˜åº¦åœ–å’Œæ¿•åº¦åœ–
        for (let y = 0; y < this.mapSize; y++) {
            this.heightMap[y] = [];
            this.moistureMap[y] = [];
            this.map[y] = [];
            
            for (let x = 0; x < this.mapSize; x++) {
                // é«˜åº¦å€¼
                const height = noise(x, y, 0.05) * 0.6 + noise(x, y, 0.1) * 0.3 + noise(x, y, 0.2) * 0.1;
                this.heightMap[y][x] = height;
                
                // æ¿•åº¦å€¼
                const moisture = noise(x + 100, y + 100, 0.04);
                this.moistureMap[y][x] = moisture;
                
                // æ ¹æ“šé«˜åº¦å’Œæ¿•åº¦æ±ºå®šåœ°å½¢
                let tile = 'grass';
                
                if (height < 0.3) {
                    tile = 'water'; // ä½åœ°æ˜¯æ°´
                } else if (height < 0.35) {
                    tile = 'sand'; // æ²™ç˜
                } else if (height > 0.75) {
                    tile = 'mountain'; // é«˜å±±
                } else if (height > 0.65) {
                    tile = 'hill'; // ä¸˜é™µ
                } else {
                    // å¹³åŸåœ°å€
                    if (moisture > 0.7) {
                        tile = 'forest'; // æ¿•æ½¤åœ°å€æ˜¯æ£®æ—
                    } else if (moisture < 0.3) {
                        tile = 'desert'; // ä¹¾ç‡¥åœ°å€
                    } else {
                        tile = 'grass'; // è‰åœ°
                    }
                }
                
                this.map[y][x] = tile;
            }
        }
        
        // æ·»åŠ åŸé®
        this.towns = [];
        const townCount = 3;
        for (let i = 0; i < townCount; i++) {
            let placed = false;
            let attempts = 0;
            while (!placed && attempts < 100) {
                const x = 20 + Math.floor(Math.random() * (this.mapSize - 40));
                const y = 20 + Math.floor(Math.random() * (this.mapSize - 40));
                
                // ç¢ºä¿åŸé®åœ¨å¹³åœ°ä¸Š
                if (this.map[y][x] === 'grass' || this.map[y][x] === 'desert') {
                    this.towns.push({ x, y, size: 3 + Math.floor(Math.random() * 3) });
                    
                    // åœ¨åŸé®å‘¨åœæ¸…ç†åœ°å½¢
                    for (let dy = -2; dy <= 2; dy++) {
                        for (let dx = -2; dx <= 2; dx++) {
                            const ny = y + dy;
                            const nx = x + dx;
                            if (ny >= 0 && ny < this.mapSize && nx >= 0 && nx < this.mapSize) {
                                if (this.map[ny][nx] !== 'water') {
                                    this.map[ny][nx] = 'town';
                                }
                            }
                        }
                    }
                    placed = true;
                }
                attempts++;
            }
        }
        
        // ç”Ÿæˆé“è·¯é€£æ¥åŸé®
        this.roads = [];
        for (let i = 0; i < this.towns.length - 1; i++) {
            const start = this.towns[i];
            const end = this.towns[i + 1];
            this.createRoad(start, end);
        }
        
        // æ·»åŠ ä¸€äº›éš¨æ©Ÿå»ºç¯‰å’Œè£é£¾
        this.decorations = [];
        for (let i = 0; i < 50; i++) {
            const x = Math.floor(Math.random() * this.mapSize);
            const y = Math.floor(Math.random() * this.mapSize);
            
            if (this.map[y][x] === 'grass') {
                const types = ['tree', 'rock', 'flower', 'house'];
                this.decorations.push({
                    x, y,
                    type: types[Math.floor(Math.random() * types.length)]
                });
            }
        }
    }
    
    createRoad(start, end) {
        // ç°¡å–®çš„A*è·¯å¾‘ç”Ÿæˆé“è·¯
        let x = start.x;
        let y = start.y;
        
        while (Math.abs(x - end.x) > 1 || Math.abs(y - end.y) > 1) {
            const dx = end.x - x;
            const dy = end.y - y;
            
            // éš¨æ©Ÿä½†å‚¾å‘ç›®æ¨™æ–¹å‘
            if (Math.random() < 0.7) {
                if (Math.abs(dx) > Math.abs(dy)) {
                    x += Math.sign(dx);
                } else {
                    y += Math.sign(dy);
                }
            } else {
                // å¶çˆ¾éš¨æ©Ÿè½‰å‘ï¼Œè®“é“è·¯æ›´è‡ªç„¶
                if (Math.random() < 0.5) {
                    x += Math.sign(dx);
                } else {
                    y += Math.sign(dy);
                }
            }
            
            // ç¢ºä¿åœ¨åœ°åœ–ç¯„åœå…§
            x = Math.max(0, Math.min(this.mapSize - 1, x));
            y = Math.max(0, Math.min(this.mapSize - 1, y));
            
            // åªåœ¨éæ°´åŸŸå»ºé€ é“è·¯
            if (this.map[y][x] !== 'water' && this.map[y][x] !== 'town') {
                this.map[y][x] = 'road';
                this.roads.push({ x, y });
            }
        }
    }
    
    generateMonsters() {
        this.monsters = [];
        for (let i = 0; i < 50; i++) { // å¢åŠ åˆå§‹æ€ªç‰©æ•¸é‡å¾20åˆ°50
            this.spawnMonster();
        }
    }
    
    spawnMonster() {
        const x = Math.floor(Math.random() * this.mapSize);
        const y = Math.floor(Math.random() * this.mapSize);
        
        if (this.map[y] && this.map[y][x] === 'grass') {
            const types = ['å¦–ç‹¼', 'å¦–ç‹', 'å±±å¦–', 'é‚ªéˆ', 'é­”è››', 'é¬¼ç«'];
            const type = types[Math.floor(Math.random() * types.length)];
            this.monsters.push({
                id: Date.now() + Math.random(),
                x: x,
                y: y,
                hp: 50,
                maxHp: 50,
                type: type,
                damage: 10,
                patrolOriginX: x,
                patrolOriginY: y,
                patrolDirection: Math.floor(Math.random() * 4),
                patrolTimer: 0,
                patrolSpeed: 0.01 + Math.random() * 0.02,
                patrolRange: 2 + Math.floor(Math.random() * 3),
                moveProgress: 0,
                targetX: x,
                targetY: y,
                actualX: x,
                actualY: y
            });
        }
    }
    
    setupInput() {
        // éµç›¤è¼¸å…¥
        window.addEventListener('keydown', (e) => {
            this.keys[e.key.toLowerCase()] = true;
            
            if (e.key >= '1' && e.key <= '6') {
                this.handleSkillKey(e.key);
            }
        });
        
        window.addEventListener('keyup', (e) => {
            this.keys[e.key.toLowerCase()] = false;
        });
        
        // æŠ€èƒ½æŒ‰éˆ•
        document.querySelectorAll('.skill-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const action = btn.dataset.action;
                this.handleAction(action);
            });
            
            // è§¸æ‘¸äº‹ä»¶é˜²æ­¢èª¤è§¸
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const action = btn.dataset.action;
                this.handleAction(action);
            });
        });
        
        // åŠŸèƒ½æŒ‰éˆ•
        document.querySelectorAll('.function-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const action = btn.dataset.action;
                this.handleAction(action);
            });
            
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const action = btn.dataset.action;
                this.handleAction(action);
            });
        });
    }
    
    handleAction(action) {
        // æ’­æ”¾é»æ“ŠéŸ³æ•ˆ
        this.playClickSound();
        
        switch(action) {
            case 'openSpellMenu':
                this.openSpellMenu();
                break;
            case 'openStorage':
                this.openStorage();
                break;
            case 'openAlchemy':
                this.openAlchemy();
                break;
            case 'openForge':
                this.openForge();
                break;
            case 'openCave':
                this.openCave();
                break;
            case 'sword':
                this.useSkill('flyingSword');
                break;
            case 'shield':
                this.useSkill('shield');
                break;
            case 'thunder':
                this.useSkill('thunder');
                break;
            case 'meditate':
                this.meditate();
                break;
            case 'breakthrough':
                this.tryBreakthrough();
                break;
            case 'spawnMonsters':
                this.spawnMonstersWave();
                break;
            case 'toggleMusic':
                this.toggleMusic();
                break;
        }
    }
    
    openSpellMenu() {
        document.getElementById('spellOverlay').classList.add('show');
        document.getElementById('spellMenu').classList.add('show');
        this.updateSpellMenu();
    }
    
    updateSpellMenu() {
        // é£›åŠè¡“
        const sword = this.skills.flyingSword;
        document.getElementById('swordLvl').textContent = sword.level;
        document.getElementById('swordCount').textContent = sword.count + ' / 12';
        document.getElementById('swordDmg').textContent = sword.damage;
        document.getElementById('swordMana').textContent = sword.manaCost;
        document.getElementById('swordCD').textContent = (sword.cooldown / 1000) + 'ç§’';
        document.getElementById('swordCost').textContent = sword.upgradeCost;
        
        // è­·ç›¾è¡“
        const shield = this.skills.shield;
        document.getElementById('shieldLvl').textContent = shield.level;
        document.getElementById('shieldAmount').textContent = shield.shieldAmount;
        document.getElementById('shieldBlock').textContent = shield.damageReduction + '%';
        document.getElementById('shieldDuration').textContent = (shield.duration / 1000).toFixed(1) + 'ç§’';
        document.getElementById('shieldMana').textContent = shield.manaCost;
        document.getElementById('shieldCost').textContent = shield.upgradeCost;
        
        // å¤©é›·è¡“
        const thunder = this.skills.thunder;
        document.getElementById('thunderLvl').textContent = thunder.level;
        document.getElementById('thunderDmg').textContent = thunder.damage;
        document.getElementById('thunderRange').textContent = thunder.range;
        document.getElementById('thunderMana').textContent = thunder.manaCost;
        document.getElementById('thunderCD').textContent = (thunder.cooldown / 1000) + 'ç§’';
        document.getElementById('thunderCost').textContent = thunder.upgradeCost;
    }
    
    upgradeSpell(spellName) {
        const skill = this.skills[spellName];
        if (!skill) return;
        
        if (spellName === 'flyingSword' && skill.level >= 24) {
            this.addLog('é£›åŠè¡“å·²é”æœ€é«˜ç­‰ç´šï¼', 'system');
            return;
        } else if (spellName !== 'flyingSword' && skill.level >= 10) {
            this.addLog('å·²é”æœ€é«˜ç­‰ç´šï¼', 'system');
            return;
        }
        
        if (this.player.lingshi < skill.upgradeCost) {
            this.addLog('éˆçŸ³ä¸è¶³ï¼', 'system');
            return;
        }
        
        this.player.lingshi -= skill.upgradeCost;
        skill.level++;
        
        // å‡ç´šæ•ˆæœ
        if (spellName === 'flyingSword') {
            skill.damage += 5;
            const newCount = Math.min(12, Math.floor(skill.level / 2) + 1);
            if (newCount > skill.count) {
                skill.count = newCount;
                this.addLog(`é£›åŠæ•¸é‡å¢åŠ åˆ°${skill.count}æŠŠï¼`, 'system');
                
                if (skill.count === 6) {
                    this.addLog('å…­åŠé½Šé£›ï¼å°æœ‰æ‰€æˆï¼', 'system');
                } else if (skill.count === 12) {
                    this.addLog('è¬åŠæ­¸å®—ï¼å¤§æˆå¢ƒç•Œï¼', 'system');
                }
            }
            skill.cooldown = Math.max(1000, skill.cooldown - 50);
        } else if (spellName === 'shield') {
            skill.shieldAmount += 10;
            if (skill.level % 2 === 0) {
                skill.damageReduction = Math.min(90, skill.damageReduction + 50);
                skill.duration = Math.floor(skill.duration * 1.2);
                this.addLog(`è­·ç›¾æ¸›å‚·${skill.damageReduction}%ï¼ŒæŒçºŒ${(skill.duration/1000).toFixed(1)}ç§’ï¼`, 'system');
            }
        } else if (spellName === 'thunder') {
            skill.damage += 10;
            skill.range += 0.5;
        }
        
        skill.upgradeCost = Math.floor(skill.upgradeCost * 1.5);
        
        this.addLog(`${skill.name}å‡ç´šåˆ°${skill.level}ç´šï¼`, 'system');
        this.updateSpellMenu();
        this.updateUI();
    }
    
    useSkill(skillName) {
        const skill = this.skills[skillName];
        if (!skill) return;
        
        const now = Date.now();
        if (now - skill.lastUse < skill.cooldown) {
            const remaining = Math.ceil((skill.cooldown - (now - skill.lastUse)) / 1000);
            this.showCooldown(skillName, remaining);
            return;
        }
        
        if (skill.manaCost > this.player.mana) {
            this.addLog('æ³•åŠ›ä¸è¶³ï¼', 'system');
            return;
        }
        
        skill.lastUse = now;
        this.player.mana -= skill.manaCost;
        
        // é¡¯ç¤ºå†·å»
        this.startCooldownAnimation(skillName, skill.cooldown);
        
        if (skillName === 'flyingSword') {
            this.launchMultipleSwords();
        } else if (skillName === 'shield') {
            this.activateShield();
        } else if (skillName === 'thunder') {
            this.thunderAttack();
        }
    }
    
    showCooldown(skillName, seconds) {
        const overlay = document.querySelector(`[data-skill="${skillName === 'flyingSword' ? 'sword' : skillName}"]`);
        if (overlay) {
            overlay.textContent = seconds + 's';
        }
    }
    
    startCooldownAnimation(skillName, duration) {
        const overlayName = skillName === 'flyingSword' ? 'sword' : skillName;
        const overlay = document.querySelector(`[data-skill="${overlayName}"]`);
        if (!overlay) return;
        
        overlay.classList.add('active');
        let remaining = Math.ceil(duration / 1000);
        overlay.textContent = remaining + 's';
        
        const interval = setInterval(() => {
            remaining--;
            if (remaining > 0) {
                overlay.textContent = remaining + 's';
            } else {
                overlay.classList.remove('active');
                overlay.textContent = '';
                clearInterval(interval);
            }
        }, 1000);
    }
    
    launchMultipleSwords() {
        const skill = this.skills.flyingSword;
        const swordCount = skill.count;
        
        let targets = [];
        this.monsters.forEach(monster => {
            const dist = Math.sqrt(
                (monster.x - this.player.x) ** 2 + 
                (monster.y - this.player.y) ** 2
            );
            targets.push({ monster, dist });
        });
        
        targets.sort((a, b) => a.dist - b.dist);
        
        if (targets.length === 0) {
            this.addLog('é™„è¿‘æ²’æœ‰æ•µäººï¼', 'system');
            return;
        }
        
        for (let i = 0; i < swordCount; i++) {
            const targetIndex = Math.min(i, targets.length - 1);
            const target = targets[targetIndex];
            
            if (!target) break;
            
            const angleOffset = (i - swordCount / 2) * 0.3;
            const speedVariation = 12 + (i % 3) * 2;
            
            const sword = {
                x: this.player.worldX,
                y: this.player.worldY,
                target: target.monster,
                speed: speedVariation,
                damage: skill.damage,
                trail: [],
                life: 150,
                homing: true,
                curveStrength: 0.1 + (i % 3) * 0.05,
                angleOffset: angleOffset,
                delay: i * 50,
                active: false,
                retargeting: true
            };
            
            const actualX = target.monster.actualX !== undefined ? target.monster.actualX : target.monster.x;
            const actualY = target.monster.actualY !== undefined ? target.monster.actualY : target.monster.y;
            const dx = actualX * this.tileSize - sword.x;
            const dy = actualY * this.tileSize - sword.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) + angleOffset;
            
            sword.vx = Math.cos(angle) * sword.speed;
            sword.vy = Math.sin(angle) * sword.speed;
            
            setTimeout(() => {
                sword.active = true;
                this.createSwordLaunchEffect(sword.x, sword.y);
            }, sword.delay);
            
            this.swords.push(sword);
        }
        
        this.player.expression = 'attack';
        setTimeout(() => this.player.expression = 'normal', 1000);
        
        if (swordCount >= 12) {
            this.addLog(`è¬åŠè¨£ï¼${swordCount}åŠé½Šç™¼ï¼`, 'skill');
        } else if (swordCount >= 6) {
            this.addLog(`å…­åˆé£›åŠï¼${swordCount}åŠå‡ºé˜ï¼`, 'skill');
        } else if (swordCount >= 3) {
            this.addLog(`ä¸‰æ‰åŠé™£ï¼${swordCount}åŠé½Šé£›ï¼`, 'skill');
        } else {
            this.addLog(`é£›åŠè¡“ Lv.${skill.level}ï¼${swordCount}åŠå‡ºæ“Šï¼`, 'skill');
        }
    }
    
    createSwordLaunchEffect(x, y) {
        for (let i = 0; i < 8; i++) {
            const angle = (Math.PI * 2 / 8) * i;
            this.particles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * 3,
                vy: Math.sin(angle) * 3,
                life: 15,
                maxLife: 15,
                size: 3,
                color: '#00bcd4',
                type: 'sword_launch'
            });
        }
    }
    
    activateShield() {
        const skill = this.skills.shield;
        const now = Date.now();
        
        this.player.shield = skill.shieldAmount;
        this.player.maxShield = skill.shieldAmount;
        this.player.shieldDamageReduction = skill.damageReduction;
        skill.activeUntil = now + skill.duration;
        
        this.player.expression = 'defensive';
        setTimeout(() => this.player.expression = 'normal', 1000);
        
        this.addLog(`è­·ç›¾è¡“ Lv.${skill.level}ï¼è­·ç›¾${skill.shieldAmount}é»ï¼Œæ¸›å‚·${skill.damageReduction}%`, 'skill');
        this.createShieldEffect();
    }
    
    thunderAttack() {
        const skill = this.skills.thunder;
        let hitCount = 0;
        
        this.player.expression = 'power';
        setTimeout(() => this.player.expression = 'normal', 1000);
        
        this.monsters.forEach(monster => {
            const actualX = monster.actualX !== undefined ? monster.actualX : monster.x;
            const actualY = monster.actualY !== undefined ? monster.actualY : monster.y;
            const dist = Math.sqrt((actualX - this.player.x) ** 2 + (actualY - this.player.y) ** 2);
            if (dist < skill.range) {
                this.damageMonster(monster, skill.damage);
                this.createThunderEffect(actualX * this.tileSize, actualY * this.tileSize);
                hitCount++;
            }
        });
        
        if (hitCount > 0) {
            this.addLog(`å¤©é›·è¡“ Lv.${skill.level}ï¼æ“Šä¸­${hitCount}å€‹ç›®æ¨™`, 'skill');
        }
    }
    
    updateSwords(deltaTime) {
        this.swords = this.swords.filter(sword => {
            if (!sword.active) return true;
            
            sword.trail.push({ x: sword.x, y: sword.y });
            if (sword.trail.length > 20) sword.trail.shift();
            
            if (sword.homing && sword.retargeting) {
                if (!this.monsters.includes(sword.target) || sword.target.hp <= 0) {
                    let minDist = Infinity;
                    let newTarget = null;
                    this.monsters.forEach(monster => {
                        if (monster.hp > 0) {
                            const actualX = monster.actualX !== undefined ? monster.actualX : monster.x;
                            const actualY = monster.actualY !== undefined ? monster.actualY : monster.y;
                            const dist = Math.sqrt(
                                (actualX * this.tileSize - sword.x) ** 2 + 
                                (actualY * this.tileSize - sword.y) ** 2
                            );
                            if (dist < minDist) {
                                minDist = dist;
                                newTarget = monster;
                            }
                        }
                    });
                    sword.target = newTarget;
                    
                    if (!newTarget) {
                        this.createSwordHitEffect(sword.x, sword.y);
                        return false;
                    }
                }
                
                if (sword.target && sword.target.hp > 0) {
                    const actualX = sword.target.actualX !== undefined ? sword.target.actualX : sword.target.x;
                    const actualY = sword.target.actualY !== undefined ? sword.target.actualY : sword.target.y;
                    const targetX = actualX * this.tileSize + 16;
                    const targetY = actualY * this.tileSize + 16;
                    const dx = targetX - sword.x;
                    const dy = targetY - sword.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 0) {
                        const turnSpeed = sword.curveStrength || 0.15;
                        sword.vx += (dx / dist * sword.speed - sword.vx) * turnSpeed;
                        sword.vy += (dy / dist * sword.speed - sword.vy) * turnSpeed;
                        
                        const currentSpeed = Math.sqrt(sword.vx * sword.vx + sword.vy * sword.vy);
                        if (currentSpeed > sword.speed) {
                            sword.vx = (sword.vx / currentSpeed) * sword.speed;
                            sword.vy = (sword.vy / currentSpeed) * sword.speed;
                        }
                    }
                }
            }
            
            sword.x += (sword.vx || 0) * deltaTime * 60;
            sword.y += (sword.vy || 0) * deltaTime * 60;
            
            const tileX = Math.floor(sword.x / this.tileSize);
            const tileY = Math.floor(sword.y / this.tileSize);
            
            for (let monster of this.monsters) {
                const dist = Math.sqrt((monster.x - tileX) ** 2 + (monster.y - tileY) ** 2);
                if (dist < 1 && monster.hp > 0) {
                    this.damageMonster(monster, sword.damage);
                    this.createSwordHitEffect(sword.x, sword.y);
                    sword.target = null;
                    sword.life = Math.min(sword.life, 30);
                }
            }
            
            sword.life--;
            return sword.life > 0;
        });
    }
    
    createSwordHitEffect(x, y) {
        for (let i = 0; i < 12; i++) {
            const angle = (Math.PI * 2 / 12) * i;
            this.particles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * 6,
                vy: Math.sin(angle) * 6,
                life: 20,
                maxLife: 20,
                size: 5,
                color: '#00bcd4',
                type: 'sword_hit'
            });
        }
    }
    
    meditate() {
        this.player.mana = Math.min(this.player.maxMana, this.player.mana + 30);
        this.player.spiritual = Math.min(this.player.maxSpiritual, this.player.spiritual + 15);
        this.player.expression = 'meditate';
        setTimeout(() => this.player.expression = 'normal', 3000);
        
        this.addLog('æ‰“åæ¢å¾©30æ³•åŠ›ï¼Œç²å¾—15éˆåŠ›', 'heal');
        this.createMeditateEffect();
        
        // æ’­æ”¾é»æ“ŠéŸ³æ•ˆ
        this.playClickSound();
    }
    
    tryBreakthrough() {
        if (this.player.spiritual >= this.player.maxSpiritual) {
            this.player.realm++;
            this.player.spiritual = 0;
            this.player.maxSpiritual += 50;
            this.player.maxMana += 50;
            this.player.mana = this.player.maxMana;
            this.player.attack += 5;
            this.player.defense += 3;
            this.player.lingshi += 200;
            
            const realms = [
                'ç…‰æ°£æœŸä¸€å±¤', 'ç…‰æ°£æœŸäºŒå±¤', 'ç…‰æ°£æœŸä¸‰å±¤',
                'ç…‰æ°£æœŸå››å±¤', 'ç…‰æ°£æœŸäº”å±¤', 'ç…‰æ°£æœŸå…­å±¤',
                'ç¯‰åŸºæœŸå‰æœŸ', 'ç¯‰åŸºæœŸä¸­æœŸ', 'ç¯‰åŸºæœŸå¾ŒæœŸ',
                'é‡‘ä¸¹æœŸ', 'å…ƒå¬°æœŸ', 'åŒ–ç¥æœŸ'
            ];
            
            document.getElementById('realmBadge').textContent = realms[this.player.realm] || 'é£›å‡å¢ƒ';
            this.addLog(`çªç ´æˆåŠŸï¼æ™‰å‡${realms[this.player.realm]}ï¼ç²å¾—200éˆçŸ³`, 'system');
            this.createBreakthroughEffect();
        } else {
            this.addLog(`éˆåŠ›ä¸è¶³ï¼Œé‚„éœ€${this.player.maxSpiritual - this.player.spiritual}é»`, 'system');
        }
    }
    
    damageMonster(monster, damage) {
        monster.hp -= damage;
        document.getElementById('sfxSwordHit').play().catch(()=>{});
        const actualX = monster.actualX !== undefined ? monster.actualX : monster.x;
        const actualY = monster.actualY !== undefined ? monster.actualY : monster.y;
        this.createDamageNumber(actualX * this.tileSize, actualY * this.tileSize, damage);
        
        if (monster.hp <= 0) {
            const index = this.monsters.indexOf(monster);
            if (index > -1) {
                this.monsters.splice(index, 1);
                this.player.spiritual += 10;
                this.player.lingshi += Math.floor(Math.random() * 20) + 10;
                this.createDeathEffect(actualX * this.tileSize, actualY * this.tileSize);
                
                // éš¨æ©Ÿæ‰è½ç‰©å“
                const dropChance = Math.random();
                if (dropChance < 0.3) {
                    const drops = [
                        { icon: 'ğŸŒ¿', name: 'éˆè‰' },
                        { icon: 'ğŸ”®', name: 'éˆçŸ³ç¢ç‰‡' },
                        { icon: 'âš™ï¸', name: 'ç²¾éµ' },
                        { icon: 'ğŸ’«', name: 'å¦–ä¸¹' }
                    ];
                    const drop = drops[Math.floor(Math.random() * drops.length)];
                    if (this.addItemToStorage(drop.icon, drop.name)) {
                        this.addLog(`ç²å¾— ${drop.name}ï¼`, 'system');
                    }
                }
                
                this.addLog(`æ“Šæ•—${monster.type}ï¼ç²å¾—10éˆåŠ›å’ŒéˆçŸ³`, 'system');
                this.updateUI();
                
                setTimeout(() => this.spawnMonster(), 3000);
            }
        }
    }
    
    handleSkillKey(key) {
        const skillMap = {
            '1': 'meditate',
            '2': 'flyingSword',
            '3': 'shield',
            '4': 'thunder',
            '5': 'breakthrough',
            '6': 'openSpellMenu'
        };
        
        const action = skillMap[key];
        if (action === 'meditate' || action === 'breakthrough') {
            this[action]();
        } else if (action === 'openSpellMenu') {
            this.openSpellMenu();
        } else if (action) {
            this.useSkill(action);
        }
    }
    
    createShieldEffect() {
        for (let i = 0; i < 20; i++) {
            const angle = (Math.PI * 2 / 20) * i;
            const radius = 30;
            this.particles.push({
                x: this.player.worldX + Math.cos(angle) * radius,
                y: this.player.worldY + Math.sin(angle) * radius,
                vx: 0,
                vy: 0,
                life: 60,
                maxLife: 60,
                size: 4,
                color: '#00e676',
                type: 'shield',
                angle: angle
            });
        }
    }
    
    createThunderEffect(x, y) {
        for (let i = 0; i < 20; i++) {
            this.particles.push({
                x: x + (Math.random() - 0.5) * 20,
                y: y - i * 10,
                vx: (Math.random() - 0.5) * 2,
                vy: 0,
                life: 10 + Math.random() * 10,
                maxLife: 20,
                size: 8 - i * 0.3,
                color: '#fff700',
                type: 'thunder'
            });
        }
    }
    
    createDeathEffect(x, y) {
        for (let i = 0; i < 15; i++) {
            const angle = Math.random() * Math.PI * 2;
            this.particles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * 4,
                vy: Math.sin(angle) * 4 - 2,
                life: 30,
                maxLife: 30,
                size: 5,
                color: '#9c27b0',
                type: 'death'
            });
        }
    }
    
    createBreakthroughEffect() {
        const x = this.player.worldX;
        const y = this.player.worldY;
        
        for (let i = 0; i < 30; i++) {
            this.particles.push({
                x: x,
                y: y - i * 5,
                vx: (Math.random() - 0.5) * 2,
                vy: -3,
                life: 60,
                maxLife: 60,
                size: 10 - i * 0.2,
                color: '#ffd700',
                type: 'breakthrough'
            });
        }
    }
    
    createMeditateEffect() {
        for (let i = 0; i < 8; i++) {
            const angle = (Math.PI * 2 / 8) * i;
            const radius = 40;
            this.particles.push({
                x: this.player.worldX + Math.cos(angle) * radius,
                y: this.player.worldY + Math.sin(angle) * radius,
                vx: -Math.cos(angle) * 0.5,
                vy: -Math.sin(angle) * 0.5,
                life: 60,
                maxLife: 60,
                size: 3,
                color: '#e1bee7',
                type: 'meditate'
            });
        }
    }
    
    createDamageNumber(x, y, damage) {
        this.damageNumbers.push({
            x: x,
            y: y,
            value: damage,
            vy: -2,
            life: 30,
            color: damage > 30 ? '#ff1744' : '#ff6b6b'
        });
    }
    updateMonsterPatrol(deltaTime) {
    this.monsters.forEach(monster => {
        // åˆå§‹åŒ–å®é™…ä½ç½®ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
        if (monster.actualX === undefined) {
            monster.actualX = monster.x;
            monster.actualY = monster.y;
            monster.targetX = monster.x;
            monster.targetY = monster.y;
            monster.patrolOriginX = monster.x;
            monster.patrolOriginY = monster.y;
            monster.patrolDirection = Math.floor(Math.random() * 4);
            monster.patrolTimer = 0;
            monster.patrolSpeed = 0.01 + Math.random() * 0.02;
            monster.patrolRange = 2 + Math.floor(Math.random() * 3);
            monster.moveProgress = 0;
        }
        
        // æ£€æŸ¥æ˜¯å¦æ¥è¿‘ç©å®¶ï¼ˆå¦‚æœæ¥è¿‘åˆ™åœæ­¢å·¡é€»ï¼‰
        const distToPlayer = Math.sqrt(
            (monster.x - this.player.x) ** 2 + 
            (monster.y - this.player.y) ** 2
        );
        
        if (distToPlayer < 8) {
            // ç©å®¶åœ¨é™„è¿‘ï¼Œæš‚åœå·¡é€»
            return;
        }
        
        // æ›´æ–°å·¡é€»è®¡æ—¶å™¨
        monster.patrolTimer += deltaTime;
        
        // å¦‚æœåˆ°è¾¾ç›®æ ‡ä½ç½®ï¼Œé€‰æ‹©æ–°çš„å·¡é€»ç›®æ ‡
        if (monster.moveProgress >= 1 || monster.patrolTimer > 3) {
            monster.moveProgress = 0;
            monster.patrolTimer = 0;
            
            // éšæœºæ”¹å˜æ–¹å‘
            const changeDirection = Math.random() < 0.3;
            if (changeDirection) {
                monster.patrolDirection = Math.floor(Math.random() * 4);
            }
            
            // è®¡ç®—ä¸‹ä¸€ä¸ªç›®æ ‡ä½ç½®
            let nextX = monster.x;
            let nextY = monster.y;
            
            switch(monster.patrolDirection) {
                case 0: // ä¸Š
                    nextY = Math.max(monster.patrolOriginY - monster.patrolRange, monster.y - 1);
                    break;
                case 1: // å³
                    nextX = Math.min(monster.patrolOriginX + monster.patrolRange, monster.x + 1);
                    break;
                case 2: // ä¸‹
                    nextY = Math.min(monster.patrolOriginY + monster.patrolRange, monster.y + 1);
                    break;
                case 3: // å·¦
                    nextX = Math.max(monster.patrolOriginX - monster.patrolRange, monster.x - 1);
                    break;
            }
            
            // æ£€æŸ¥ç›®æ ‡ä½ç½®æ˜¯å¦å¯è¡Œèµ°
            if (nextX >= 0 && nextX < this.mapSize && 
                nextY >= 0 && nextY < this.mapSize) {
                const tile = this.map[nextY][nextX];
                if (tile === 'grass' || tile === 'forest' || tile === 'desert') {
                    // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–æ€ªç‰©
                    const occupied = this.monsters.some(other => 
                        other.id !== monster.id && 
                        other.x === nextX && 
                        other.y === nextY
                    );
                    
                    if (!occupied) {
                        monster.targetX = nextX;
                        monster.targetY = nextY;
                    } else {
                        // å¦‚æœè¢«å ç”¨ï¼Œæ”¹å˜æ–¹å‘
                        monster.patrolDirection = (monster.patrolDirection + 1) % 4;
                    }
                } else {
                    // é‡åˆ°éšœç¢ç‰©ï¼Œæ”¹å˜æ–¹å‘
                    monster.patrolDirection = (monster.patrolDirection + 2) % 4;
                }
            }
        }
        
        // å¹³æ»‘ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®
        if (monster.x !== monster.targetX || monster.y !== monster.targetY) {
            monster.moveProgress += monster.patrolSpeed;
            
            if (monster.moveProgress >= 1) {
                monster.moveProgress = 1;
                monster.x = monster.targetX;
                monster.y = monster.targetY;
                monster.actualX = monster.x;
                monster.actualY = monster.y;
            } else {
                // æ’å€¼è®¡ç®—å®é™…æ˜¾ç¤ºä½ç½®
                const startX = monster.x;
                const startY = monster.y;
                monster.actualX = startX + (monster.targetX - startX) * monster.moveProgress;
                monster.actualY = startY + (monster.targetY - startY) * monster.moveProgress;
            }
        }
    });
}
    update(deltaTime) {
        // è™•ç†è¼¸å…¥ï¼ˆéµç›¤å’Œæ–æ¡¿ï¼‰
        let dx = 0, dy = 0;
        
        // éµç›¤è¼¸å…¥
        if (this.keys['w'] || this.keys['arrowup']) {
            dy = -1;
            this.player.facing = 'up';
        }
        if (this.keys['s'] || this.keys['arrowdown']) {
            dy = 1;
            this.player.facing = 'down';
        }
        if (this.keys['a'] || this.keys['arrowleft']) {
            dx = -1;
            this.player.facing = 'left';
        }
        if (this.keys['d'] || this.keys['arrowright']) {
            dx = 1;
            this.player.facing = 'right';
        }
        
        // æ–æ¡¿è¼¸å…¥å„ªå…ˆç´šæ›´é«˜
        if (Math.abs(this.joystickInput.x) > 0.1 || Math.abs(this.joystickInput.y) > 0.1) {
            dx = this.joystickInput.x;
            dy = this.joystickInput.y;
            
            // æ›´æ–°é¢å‘
            if (Math.abs(dx) > Math.abs(dy)) {
                this.player.facing = dx > 0 ? 'right' : 'left';
            } else {
                this.player.facing = dy > 0 ? 'down' : 'up';
            }
        }
        
        if (dx !== 0 || dy !== 0) {
            // æ­¸ä¸€åŒ–æ–œå‘ç§»å‹•é€Ÿåº¦
            if (dx !== 0 && dy !== 0) {
                const length = Math.sqrt(dx * dx + dy * dy);
                dx /= length;
                dy /= length;
            }
            
            const speed = this.player.speed * deltaTime * 60;
            const newX = this.player.worldX + dx * speed;
            const newY = this.player.worldY + dy * speed;
            
            const tileX = Math.floor(newX / this.tileSize);
            const tileY = Math.floor(newY / this.tileSize);
            
            if (tileX >= 0 && tileX < this.mapSize && tileY >= 0 && tileY < this.mapSize) {
                const tile = this.map[tileY][tileX];
                if (tile !== 'water' && tile !== 'rock') {
                    this.player.worldX = newX;
                    this.player.worldY = newY;
                    this.player.x = tileX;
                    this.player.y = tileY;
                    this.player.moving = true;
                    this.player.walkFrame += this.player.walkSpeed;
                }
            }
        } else {
            this.player.moving = false;
            this.player.walkFrame = 0;
        }
        
        // æ›´æ–°ç›¸æ©Ÿ
        this.camera.x = this.player.worldX - this.width / 2;
        this.camera.y = this.player.worldY - this.height / 2;
        
        // æ›´æ–°é£›åŠ
        this.updateMonsterPatrol(deltaTime);
        this.updateSwords(deltaTime);
        
        // æ›´æ–°ç²’å­
        this.particles = this.particles.filter(p => {
            if (p.type === 'shield') {
                p.angle += 0.05;
                p.x = this.player.worldX + Math.cos(p.angle) * 30;
                p.y = this.player.worldY + Math.sin(p.angle) * 30;
            } else {
                p.x += p.vx || 0;
                p.y += p.vy || 0;
                
                if (p.type === 'death') {
                    p.vy += 0.1;
                }
            }
            
            p.life--;
            return p.life > 0;
        });
        
        // æ›´æ–°å‚·å®³æ•¸å­—
        this.damageNumbers = this.damageNumbers.filter(dn => {
            dn.y += dn.vy;
            dn.vy += 0.1;
            dn.life--;
            return dn.life > 0;
        });
        
        // è­·ç›¾æ™‚é–“æª¢æŸ¥
        const now = Date.now();
        if (this.player.shield > 0 && this.skills.shield.activeUntil < now) {
            this.player.shield = 0;
            this.player.shieldDamageReduction = 0;
            this.addLog('è­·ç›¾æ¶ˆå¤±', 'system');
        }
        
        // è‡ªå‹•æ¢å¾©
        if (Math.random() < 0.01) {
            this.player.mana = Math.min(this.player.maxMana, this.player.mana + 1);
        }
        
        this.updateUI();
    }
    
    drawCharacterSprite(x, y) {
        const ctx = this.ctx;
        
        // åªä½¿ç”¨æ‰“ååœ–ç‰‡ä½œç‚ºè§’è‰²
        const sprite = this.sprites.meditate;
        
        if (!sprite) {
            // å¦‚æœåœ–ç‰‡æœªè¼‰å…¥ï¼Œç¹ªè£½ç°¡å–®çš„ä½”ä½ç¬¦
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(x, y + 30, 24, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#5c9ead';
            ctx.beginPath();
            ctx.arc(x, y, 30, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.save();
            
            // å¦‚æœé¢å‘å·¦é‚Šï¼Œæ°´å¹³ç¿»è½‰
            if (this.player.facing === 'left') {
                ctx.scale(-1, 1);
                x = -x;
            }
            
            // ç¹ªè£½ç²¾éˆåœ– - ä½¿ç”¨æ¨™æº–å¤§å°
            const scale = this.player.spriteScale;
            const width = 32 * scale;  // ä¿æŒå’Œå…¶ä»–ç²¾éˆåœ–ç›¸åŒçš„å¤§å°
            const height = 32 * scale;
            
            ctx.drawImage(sprite, x - width/2, y - height/2, width, height);
            
            ctx.restore();
        }
        
        // ç¹ªè£½è­·ç›¾æ•ˆæœï¼ˆèª¿æ•´å¤§å°ä»¥é…åˆæ›´å¤§çš„è§’è‰²ï¼‰
        if (this.player.shield > 0) {
            const shieldStrength = this.player.shield / this.player.maxShield;
            ctx.strokeStyle = '#00e676';
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.3 + shieldStrength * 0.4 + Math.sin(Date.now() * 0.005) * 0.1;
            ctx.beginPath();
            ctx.arc(x, y, 70, 0, Math.PI * 2);  // è­·ç›¾åŠå¾‘å¾35å¢åŠ åˆ°70
            ctx.stroke();
            
            if (this.player.shieldDamageReduction > 0) {
                ctx.fillStyle = '#00e676';
                ctx.globalAlpha = 0.8;
                ctx.font = 'bold 14px Arial';  // å­—é«”ä¹Ÿç›¸æ‡‰å¢å¤§
                ctx.textAlign = 'center';
                ctx.fillText(`-${this.player.shieldDamageReduction}%`, x, y - 80);
            }
            
            ctx.globalAlpha = 1;
        }
        
        // å¢ƒç•Œå…‰ç’°ï¼ˆèª¿æ•´å¤§å°ä»¥é…åˆæ›´å¤§çš„è§’è‰²ï¼‰
        if (this.player.realm >= 6) {
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.003) * 0.2;
            ctx.beginPath();
            ctx.arc(x, y - 20, 60, 0, Math.PI * 2);  // å…‰ç’°åŠå¾‘å¾30å¢åŠ åˆ°60
            ctx.stroke();
            ctx.globalAlpha = 1;
        }
    }
    
    drawMonster(ctx, x, y, monster) {
        // å˜—è©¦ä½¿ç”¨æ€ªç‰©ç²¾éˆåœ–
        let monsterSprite = null;
        const monsterType = monster.type;
        
        // æ ¹æ“šæ€ªç‰©é¡å‹é¸æ“‡å°æ‡‰çš„ç²¾éˆåœ–
        if (monsterType === 'å¦–ç‹¼' && this.monsterSprites.wolf) {
            monsterSprite = this.monsterSprites.wolf;
        } else if (monsterType === 'å¦–ç‹' && this.monsterSprites.fox) {
            monsterSprite = this.monsterSprites.fox;
        } else if (monsterType === 'å±±å¦–' && this.monsterSprites.mountain) {
            monsterSprite = this.monsterSprites.mountain;
        } else if (monsterType === 'é‚ªéˆ' && this.monsterSprites.spirit) {
            monsterSprite = this.monsterSprites.spirit;
        } else if (monsterType === 'é­”è››' && this.monsterSprites.spider) {
            monsterSprite = this.monsterSprites.spider;
        } else if (monsterType === 'é¬¼ç«' && this.monsterSprites.ghostfire) {
            monsterSprite = this.monsterSprites.ghostfire;
        }
        
        // å¦‚æœæœ‰å°æ‡‰çš„ç²¾éˆåœ–ï¼Œä½¿ç”¨åœ–ç‰‡ç¹ªè£½
        if (monsterSprite && monsterSprite.complete) {
            ctx.drawImage(monsterSprite, x - 32, y - 32, 64, 64);
        } else {
            // å¦å‰‡ä½¿ç”¨åŸæœ¬çš„ç¨‹å¼ç¹ªè£½
            // æ€ªç‰©é™°å½±
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(x, y + 8, 15, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // æ€ªç‰©èº«é«”
            const colors = {
                'å¦–ç‹¼': '#795548',
                'å¦–ç‹': '#FF6E40',
                'å±±å¦–': '#558B2F',
                'é‚ªéˆ': '#7E57C2',
                'é­”è››': '#424242',
                'é¬¼ç«': '#1976D2'
            };
            
            ctx.fillStyle = colors[monster.type] || '#DC2626';
            ctx.beginPath();
            ctx.arc(x, y, 12, 0, Math.PI * 2);
            ctx.fill();
            
            // æ€ªç‰©çœ¼ç›
            ctx.fillStyle = '#FF0000';
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#FF0000';
            ctx.beginPath();
            ctx.arc(x - 4, y - 2, 2, 0, Math.PI * 2);
            ctx.arc(x + 4, y - 2, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        
        // è¡€æ¢
        if (monster.hp < monster.maxHp) {
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(x - 15, y - 20, 30, 4);
            ctx.fillStyle = '#DC2626';
            ctx.fillRect(x - 15, y - 20, 30 * (monster.hp / monster.maxHp), 4);
        }
        
        // æ€ªç‰©ç­‰ç´šæ¨™ç¤ºï¼ˆå¦‚æœæœ‰ï¼‰
        if (monster.level && monster.level > 1) {
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Lv.${monster.level}`, x, y - 25);
        }
    }
    
    render() {
        const ctx = this.ctx;
        
        // å¤©ç©ºèƒŒæ™¯æ¼¸è®Š
        const skyGradient = ctx.createLinearGradient(0, 0, 0, this.height);
        skyGradient.addColorStop(0, '#87CEEB');
        skyGradient.addColorStop(0.4, '#98D8E8');
        skyGradient.addColorStop(1, '#F0E68C');
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, this.width, this.height);
        
        const startX = Math.floor(this.camera.x / this.tileSize);
        const startY = Math.floor(this.camera.y / this.tileSize);
        const endX = startX + Math.ceil(this.width / this.tileSize) + 2;
        const endY = startY + Math.ceil(this.height / this.tileSize) + 2;
        
        // ç¬¬ä¸€å±¤ï¼šç¹ªè£½åŸºç¤åœ°å½¢
        for (let y = Math.max(0, startY); y < Math.min(this.mapSize, endY); y++) {
            for (let x = Math.max(0, startX); x < Math.min(this.mapSize, endX); x++) {
                const tile = this.map[y][x];
                const screenX = x * this.tileSize - this.camera.x;
                const screenY = y * this.tileSize - this.camera.y;
                
                // ä½¿ç”¨åœ–ç‰‡åœ–å¡Šæˆ–å›é€€åˆ°é¡è‰²
                let tileImage = null;
                let fallbackColor = '#4CAF50';
                
                switch(tile) {
                    case 'water':
                        tileImage = this.tiles.water;
                        fallbackColor = '#2196F3';
                        break;
                    case 'sand':
                        tileImage = this.tiles.sand;
                        fallbackColor = '#F4E4C1';
                        break;
                    case 'grass':
                        tileImage = this.tiles.grass;
                        fallbackColor = '#4CAF50';
                        break;
                    case 'forest':
                        tileImage = this.tiles.forest;
                        fallbackColor = '#1B5E20';
                        break;
                    case 'desert':
                        tileImage = this.tiles.sand; // ä½¿ç”¨æ²™åœ°åœ–å¡Šä»£æ›¿æ²™æ¼ 
                        fallbackColor = '#D4A76A';
                        break;
                    case 'hill':
                        tileImage = this.tiles.mountain;
                        fallbackColor = '#8D6E63';
                        break;
                    case 'mountain':
                        tileImage = this.tiles.mountain;
                        fallbackColor = '#5D4037';
                        break;
                    case 'road':
                        tileImage = this.tiles.road;
                        fallbackColor = '#8D6E63';
                        break;
                    case 'town':
                        tileImage = this.tiles.road; // æš«æ™‚ç”¨é“è·¯ä»£æ›¿åŸé®åœ°é¢
                        fallbackColor = '#BCAAA4';
                        break;
                }
                
                if (tileImage && tileImage.complete) {
                    // ç¹ªè£½åœ–ç‰‡åœ–å¡Šï¼ˆå¾1024x1024ç¸®æ”¾åˆ°32x32ï¼‰
                    ctx.drawImage(tileImage, screenX, screenY, this.tileSize, this.tileSize);
                } else {
                    // å¦‚æœåœ–ç‰‡æœªè¼‰å…¥ï¼Œä½¿ç”¨é¡è‰²å¡«å……
                    ctx.fillStyle = fallbackColor;
                    ctx.fillRect(screenX, screenY, this.tileSize, this.tileSize);
                }
            }
        }
        
        // ç¬¬äºŒå±¤ï¼šç¹ªè£½è£é£¾ç‰©ï¼ˆæ¨¹æœ¨ã€å»ºç¯‰ç­‰ï¼‰
        for (let y = Math.max(0, startY); y < Math.min(this.mapSize, endY); y++) {
            for (let x = Math.max(0, startX); x < Math.min(this.mapSize, endX); x++) {
                const tile = this.map[y][x];
                const screenX = x * this.tileSize - this.camera.x;
                const screenY = y * this.tileSize - this.camera.y;
                
                // æ£®æ—ä¸­çš„æ¨¹æœ¨
                if (tile === 'forest' && Math.random() > 0.7) {
                    if (this.tiles.tree && this.tiles.tree.complete) {
                        // ç¹ªè£½æ¨¹æœ¨ï¼Œç¨å¾®å¤§ä¸€äº›
                        ctx.drawImage(this.tiles.tree, screenX - 8, screenY - 16, 48, 48);
                    } else {
                        this.drawTree(ctx, screenX + 8, screenY + 8, 12);
                        this.drawTree(ctx, screenX + 24, screenY + 20, 10);
                    }
                }
            }
        }
        
        // ç¹ªè£½åŸé®å»ºç¯‰
        this.towns.forEach(town => {
            const centerX = town.x * this.tileSize - this.camera.x;
            const centerY = town.y * this.tileSize - this.camera.y;
            
            // ç¹ªè£½æˆ¿å±‹
            if (this.tiles.house && this.tiles.house.complete) {
                for (let i = 0; i < town.size; i++) {
                    const angle = (Math.PI * 2 / town.size) * i;
                    const bx = centerX + Math.cos(angle) * 40 - 32;
                    const by = centerY + Math.sin(angle) * 40 - 32;
                    ctx.drawImage(this.tiles.house, bx, by, 64, 64);
                }
            } else {
                // å›é€€åˆ°ç¨‹å¼ç¹ªè£½
                for (let i = 0; i < town.size; i++) {
                    const angle = (Math.PI * 2 / town.size) * i;
                    const bx = centerX + Math.cos(angle) * 40;
                    const by = centerY + Math.sin(angle) * 40;
                    this.drawBuilding(ctx, bx, by, i % 3);
                }
            }
            
            // åŸé®ä¸­å¿ƒï¼ˆå¸‚å ´ï¼‰
            this.drawMarket(ctx, centerX, centerY);
        });
        
        // ç¹ªè£½é¡å¤–è£é£¾
        this.decorations.forEach(deco => {
            const screenX = deco.x * this.tileSize - this.camera.x;
            const screenY = deco.y * this.tileSize - this.camera.y;
            
            switch(deco.type) {
                case 'tree':
                    if (this.tiles.tree && this.tiles.tree.complete) {
                        ctx.drawImage(this.tiles.tree, screenX - 16, screenY - 16, 64, 64);
                    } else {
                        this.drawTree(ctx, screenX + 16, screenY + 20, 15);
                    }
                    break;
                case 'rock':
                    if (this.tiles.rock && this.tiles.rock.complete) {
                        ctx.drawImage(this.tiles.rock, screenX, screenY, 32, 32);
                    } else {
                        this.drawRock(ctx, screenX + 16, screenY + 16);
                    }
                    break;
                case 'flower':
                    if (this.tiles.flowers && this.tiles.flowers.complete) {
                        ctx.drawImage(this.tiles.flowers, screenX, screenY, 32, 32);
                    } else {
                        this.drawFlowers(ctx, screenX + 16, screenY + 16);
                    }
                    break;
                case 'house':
                    if (this.tiles.house && this.tiles.house.complete) {
                        ctx.drawImage(this.tiles.house, screenX - 16, screenY - 16, 64, 64);
                    } else {
                        this.drawBuilding(ctx, screenX, screenY, 0);
                    }
                    break;
            }
        });
        
        // æ¸²æŸ“æ€ªç‰©
        this.monsters.forEach(monster => {
            const actualX = monster.actualX !== undefined ? monster.actualX : monster.x;
            const actualY = monster.actualY !== undefined ? monster.actualY : monster.y;
            const screenX = actualX * this.tileSize - this.camera.x + 16;
            const screenY = actualY * this.tileSize - this.camera.y + 16;
            
            // æª¢æŸ¥æ˜¯å¦åœ¨ç•«é¢ç¯„åœå…§
            if (screenX > -50 && screenX < this.width + 50 && 
                screenY > -50 && screenY < this.height + 50) {
                this.drawMonster(ctx, screenX, screenY, monster);
            }
        });
        
        // æ¸²æŸ“é£›åŠ
        this.swords.forEach((sword, index) => {
            if (!sword.active) return;
            
            const screenX = sword.x - this.camera.x;
            const screenY = sword.y - this.camera.y;
            
            const hue = 180 + (index * 30) % 180;
            const swordColor = `hsl(${hue}, 100%, 50%)`;
            
            // è»Œè·¡
            ctx.strokeStyle = swordColor;
            ctx.lineWidth = 2 + (index % 2);
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            sword.trail.forEach((point, i) => {
                const px = point.x - this.camera.x;
                const py = point.y - this.camera.y;
                const alpha = i / sword.trail.length;
                ctx.globalAlpha = alpha * 0.6;
                
                if (i === 0) {
                    ctx.moveTo(px, py);
                } else {
                    ctx.lineTo(px, py);
                }
            });
            ctx.stroke();
            ctx.globalAlpha = 1;
            
            // åŠèº«
            ctx.save();
            ctx.translate(screenX, screenY);
            const angle = Math.atan2(sword.vy || 0, sword.vx || 1);
            ctx.rotate(angle);
            
            const gradient = ctx.createLinearGradient(-15, 0, 15, 0);
            gradient.addColorStop(0, `hsla(${hue}, 100%, 50%, 0.6)`);
            gradient.addColorStop(0.5, '#ffffff');
            gradient.addColorStop(1, `hsla(${hue}, 100%, 50%, 0.6)`);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(-15, -2, 30, 4);
            
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(15, -3);
            ctx.lineTo(20, 0);
            ctx.lineTo(15, 3);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
            
            // å…‰æšˆ
            ctx.globalAlpha = 0.4;
            const glowGradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, 15);
            glowGradient.addColorStop(0, `hsla(${hue}, 100%, 70%, 0.8)`);
            glowGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(screenX, screenY, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        });
        
        // æ¸²æŸ“ç²’å­
        this.particles.forEach(p => {
            const screenX = p.x - this.camera.x;
            const screenY = p.y - this.camera.y;
            
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life / p.maxLife;
            
            if (p.type === 'thunder') {
                ctx.strokeStyle = p.color;
                ctx.lineWidth = p.size;
                ctx.beginPath();
                ctx.moveTo(screenX, screenY);
                ctx.lineTo(screenX + Math.random() * 20 - 10, screenY + 10);
                ctx.stroke();
            } else if (p.type === 'breakthrough') {
                const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, p.size);
                gradient.addColorStop(0, '#fff');
                gradient.addColorStop(0.5, p.color);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(screenX - p.size, screenY - p.size * 2, p.size * 2, p.size * 4);
            } else {
                ctx.beginPath();
                ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
        });
        
        ctx.globalAlpha = 1;
        
        // æ¸²æŸ“ç©å®¶ï¼ˆä½¿ç”¨ç²¾éˆåœ–ï¼‰
        const playerScreenX = this.player.worldX - this.camera.x;
        const playerScreenY = this.player.worldY - this.camera.y;
        
        this.drawCharacterSprite(playerScreenX, playerScreenY);
        
        // æ¸²æŸ“å‚·å®³æ•¸å­—
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        this.damageNumbers.forEach(dn => {
            const screenX = dn.x - this.camera.x;
            const screenY = dn.y - this.camera.y;
            
            ctx.globalAlpha = dn.life / 30;
            ctx.fillStyle = dn.color;
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.strokeText(dn.value, screenX, screenY);
            ctx.fillText(dn.value, screenX, screenY);
        });
        
        ctx.globalAlpha = 1;
    }
    
    // è¼”åŠ©ç¹ªåœ–å‡½æ•¸
    drawTree(ctx, x, y, size) {
        // æ¨¹å¹¹
        ctx.fillStyle = '#6D4C41';
        ctx.fillRect(x - size/6, y, size/3, size/2);
        
        // æ¨¹è‘‰ï¼ˆå¤šå±¤ï¼‰
        const leafColors = ['#2E7D32', '#388E3C', '#43A047'];
        leafColors.forEach((color, i) => {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y - size/2 + i * 3, size * 0.8 - i * 2, 0, Math.PI * 2);
            ctx.fill();
        });
        
        // æ¨¹è‘‰é«˜å…‰
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.beginPath();
        ctx.arc(x - size/4, y - size/2, size/3, 0, Math.PI * 2);
        ctx.fill();
    }
    
    drawBuilding(ctx, x, y, type) {
        // å»ºç¯‰é™°å½±
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(x + 2, y + 2, 40, 35);
        
        // å»ºç¯‰ä¸»é«”
        const colors = ['#D4A373', '#C0392B', '#7B68EE'];
        ctx.fillStyle = colors[type % colors.length];
        ctx.fillRect(x, y, 40, 35);
        
        // å±‹é ‚
        ctx.fillStyle = '#8B4513';
        ctx.beginPath();
        ctx.moveTo(x - 5, y);
        ctx.lineTo(x + 20, y - 15);
        ctx.lineTo(x + 45, y);
        ctx.closePath();
        ctx.fill();
        
        // é–€
        ctx.fillStyle = '#4A2C17';
        ctx.fillRect(x + 15, y + 15, 10, 20);
        
        // çª—æˆ¶
        ctx.fillStyle = '#FFF59D';
        ctx.fillRect(x + 5, y + 8, 8, 8);
        ctx.fillRect(x + 27, y + 8, 8, 8);
        
        // çª—æˆ¶åå­—æ¶
        ctx.strokeStyle = '#4A2C17';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x + 9, y + 8);
        ctx.lineTo(x + 9, y + 16);
        ctx.moveTo(x + 5, y + 12);
        ctx.lineTo(x + 13, y + 12);
        ctx.stroke();
    }
    
    drawMarket(ctx, x, y) {
        // å¸‚å ´æ”¤ä½
        ctx.fillStyle = '#8D6E63';
        ctx.fillRect(x - 20, y - 10, 40, 20);
        
        // é®é™½æ£š
        ctx.fillStyle = '#FF6F61';
        ctx.beginPath();
        ctx.moveTo(x - 25, y - 10);
        ctx.lineTo(x, y - 20);
        ctx.lineTo(x + 25, y - 10);
        ctx.closePath();
        ctx.fill();
        
        // å•†å“
        ctx.fillStyle = '#FFA726';
        ctx.beginPath();
        ctx.arc(x - 10, y, 3, 0, Math.PI * 2);
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.arc(x + 10, y, 3, 0, Math.PI * 2);
        ctx.fill();
    }
    
    drawRock(ctx, x, y) {
        // å²©çŸ³é™°å½±
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(x, y + 5, 12, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // å²©çŸ³ä¸»é«”
        const gradient = ctx.createRadialGradient(x - 3, y - 3, 0, x, y, 10);
        gradient.addColorStop(0, '#9E9E9E');
        gradient.addColorStop(1, '#616161');
        ctx.fillStyle = gradient;
        
        ctx.beginPath();
        ctx.moveTo(x - 8, y + 3);
        ctx.lineTo(x - 6, y - 5);
        ctx.lineTo(x + 2, y - 8);
        ctx.lineTo(x + 8, y - 4);
        ctx.lineTo(x + 10, y + 3);
        ctx.closePath();
        ctx.fill();
        
        // å²©çŸ³ç´‹ç†
        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x - 4, y - 2);
        ctx.lineTo(x + 3, y + 1);
        ctx.stroke();
    }
    
    drawFlowers(ctx, x, y) {
        // å¤šæœµå°èŠ±
        const colors = ['#FF69B4', '#FFB6C1', '#FFA07A'];
        for (let i = 0; i < 3; i++) {
            const fx = x + (Math.random() - 0.5) * 10;
            const fy = y + (Math.random() - 0.5) * 10;
            
            // èŠ±è–
            ctx.strokeStyle = '#228B22';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(fx, fy);
            ctx.lineTo(fx, fy + 5);
            ctx.stroke();
            
            // èŠ±ç“£
            ctx.fillStyle = colors[i % colors.length];
            for (let j = 0; j < 5; j++) {
                const angle = (Math.PI * 2 / 5) * j;
                const px = fx + Math.cos(angle) * 3;
                const py = fy + Math.sin(angle) * 3;
                ctx.beginPath();
                ctx.arc(px, py, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // èŠ±å¿ƒ
            ctx.fillStyle = '#FFEB3B';
            ctx.beginPath();
            ctx.arc(fx, fy, 1.5, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    updateUI() {
        document.getElementById('manaBar').style.width = 
            (this.player.mana / this.player.maxMana * 100) + '%';
        
        document.getElementById('spiritualBar').style.width = 
            (this.player.spiritual / this.player.maxSpiritual * 100) + '%';
        
        document.getElementById('lingshiAmount').textContent = this.player.lingshi;
    }
    
    addLog(message, type) {
        const log = document.getElementById('combatLog');
        const div = document.createElement('div');
        div.className = `log-message log-${type}`;
        div.textContent = message;
        
        // æ·»åŠ æ¨£å¼
        switch(type) {
            case 'damage':
                div.style.color = '#ff6b6b';
                break;
            case 'heal':
                div.style.color = '#4caf50';
                break;
            case 'skill':
                div.style.color = '#00bcd4';
                break;
            case 'system':
                div.style.color = '#ffd700';
                break;
            default:
                div.style.color = '#ffffff';
        }
        
        log.appendChild(div);
        log.scrollTop = log.scrollHeight;
        
        while (log.children.length > 8) {
            log.removeChild(log.firstChild);
        }
    }
    
    gameLoop() {
        const currentTime = Date.now();
        const deltaTime = (currentTime - this.lastTime) / 1000;
        this.lastTime = currentTime;
        
        const clampedDelta = Math.min(deltaTime, 0.1);
        
        this.update(clampedDelta);
        this.render();
        
        this.animationId = requestAnimationFrame(() => this.gameLoop());
    }
}

// å…¨å±€å‡½æ•¸
function closeSpellMenu() {
    document.getElementById('spellOverlay').classList.remove('show');
    document.getElementById('spellMenu').classList.remove('show');
}

function closePanel(panelId) {
    document.getElementById(panelId).classList.remove('show');
}

function upgradeSpell(spellName) {
    if (window.game) {
        window.game.upgradeSpell(spellName);
    }
}

function selectRecipe(recipeType) {
    if (window.game) {
        window.game.alchemy.selectedRecipe = recipeType;
        document.querySelectorAll('.recipe-item').forEach(item => {
            item.style.border = '2px solid rgba(76, 175, 80, 0.3)';
        });
        event.currentTarget.style.border = '2px solid #4caf50';
    }
}

function refineAlchemy() {
    if (!window.game) return;
    
    const recipe = window.game.alchemy.selectedRecipe;
    if (!recipe) {
        window.game.addLog('è«‹å…ˆé¸æ“‡ä¸¹æ–¹ï¼', 'system');
        return;
    }
    
    // æª¢æŸ¥ææ–™
    const hasHerbs = window.game.storage.items.find(item => item && item.name === 'éˆè‰');
    if (!hasHerbs || hasHerbs.count < 3) {
        window.game.addLog('ææ–™ä¸è¶³ï¼éœ€è¦3å€‹éˆè‰', 'system');
        return;
    }
    
    // æ¶ˆè€—ææ–™
    hasHerbs.count -= 3;
    if (hasHerbs.count <= 0) {
        const index = window.game.storage.items.indexOf(hasHerbs);
        window.game.storage.items[index] = null;
    }
    
    // ç…‰è£½åˆ¤å®š
    const success = Math.random() * 100 < window.game.alchemy.successRate;
    if (success) {
        const recipes = window.game.alchemy.recipes;
        let pillName = '';
        let effect = '';
        
        switch(recipe) {
            case 'healing':
                pillName = 'å›å…ƒä¸¹';
                window.game.addItemToStorage('ğŸ’Š', pillName);
                break;
            case 'spiritual':
                pillName = 'èšéˆä¸¹';
                window.game.addItemToStorage('ğŸ’Š', pillName);
                break;
            case 'breakthrough':
                pillName = 'ç ´å¢ƒä¸¹';
                window.game.addItemToStorage('ğŸ’Š', pillName);
                break;
        }
        
        window.game.addLog(`ç…‰è£½æˆåŠŸï¼ç²å¾— ${pillName}`, 'system');
    } else {
        window.game.addLog('ç…‰è£½å¤±æ•—ï¼ææ–™æå¤±', 'system');
    }
    
    window.game.initStorage();
}

function selectEquipment(equipType) {
    if (window.game) {
        window.game.forge.selectedEquipment = equipType;
        document.querySelectorAll('.equipment-item').forEach(item => {
            item.style.border = '2px solid rgba(255, 87, 34, 0.3)';
        });
        event.currentTarget.style.border = '2px solid #ff5722';
    }
}

function forgeEquipment() {
    if (!window.game) return;
    
    const equip = window.game.forge.selectedEquipment;
    if (!equip) {
        window.game.addLog('è«‹å…ˆé¸æ“‡è£å‚™ï¼', 'system');
        return;
    }
    
    // æª¢æŸ¥ææ–™
    const hasIron = window.game.storage.items.find(item => item && item.name === 'ç²¾éµ');
    if (!hasIron || hasIron.count < 2) {
        window.game.addLog('ææ–™ä¸è¶³ï¼éœ€è¦2å€‹ç²¾éµ', 'system');
        return;
    }
    
    const equipment = window.game.forge.equipment[equip];
    if (window.game.player.lingshi < equipment.cost) {
        window.game.addLog('éˆçŸ³ä¸è¶³ï¼', 'system');
        return;
    }
    
    // æ¶ˆè€—ææ–™
    hasIron.count -= 2;
    if (hasIron.count <= 0) {
        const index = window.game.storage.items.indexOf(hasIron);
        window.game.storage.items[index] = null;
    }
    window.game.player.lingshi -= equipment.cost;
    
    // é›é€ æˆåŠŸ
    switch(equip) {
        case 'sword':
            window.game.player.attack += equipment.attack;
            window.game.addItemToStorage('âš”ï¸', equipment.name);
            break;
        case 'armor':
            window.game.player.defense += equipment.defense;
            window.game.addItemToStorage('ğŸ›¡ï¸', equipment.name);
            break;
        case 'ring':
            window.game.player.maxMana += equipment.maxMana;
            window.game.player.mana = window.game.player.maxMana;
            window.game.addItemToStorage('ğŸ’', equipment.name);
            break;
    }
    
    window.game.addLog(`é›é€ æˆåŠŸï¼ç²å¾— ${equipment.name}`, 'system');
    window.game.updateUI();
    window.game.initStorage();
}

function upgradeRoom(roomType) {
    if (!window.game) return;
    
    const room = window.game.cave.rooms[roomType];
    if (!room) return;
    
    if (window.game.player.lingshi < room.upgradeCost) {
        window.game.addLog('éˆçŸ³ä¸è¶³ï¼', 'system');
        return;
    }
    
    window.game.player.lingshi -= room.upgradeCost;
    room.level++;
    
    // å‡ç´šæ•ˆæœ
    switch(roomType) {
        case 'training':
            room.effect += 0.1;
            window.game.addLog(`ä¿®ç…‰å®¤å‡ç´šï¼ä¿®ç…‰é€Ÿåº¦+${(room.effect * 100).toFixed(0)}%`, 'system');
            break;
        case 'farm':
            room.production += 1;
            window.game.addLog(`éˆç”°å‡ç´šï¼æ¯å°æ™‚ç”¢å‡º${room.production}è‰è—¥`, 'system');
            break;
        case 'array':
            room.manaRegen += 0.1;
            window.game.addLog(`èšéˆé™£å‡ç´šï¼æ³•åŠ›æ¢å¾©+${(room.manaRegen * 100).toFixed(0)}%`, 'system');
            break;
        case 'treasury':
            room.storageBonus += 8;
            window.game.storage.maxSlots += 8;
            window.game.addLog(`å¯¶åº«å‡ç´šï¼å„²ç‰©ç©ºé–“+8`, 'system');
            window.game.initStorage();
            break;
    }
    
    room.upgradeCost = Math.floor(room.upgradeCost * 1.5);
    
    // æ›´æ–°æ´åºœç­‰ç´šå’Œæ”¶ç›Š
    window.game.cave.level = Math.floor(
        (window.game.cave.rooms.training.level + 
         window.game.cave.rooms.farm.level + 
         window.game.cave.rooms.array.level + 
         window.game.cave.rooms.treasury.level) / 4
    );
    window.game.cave.dailyIncome = 10 * window.game.cave.level;
    window.game.cave.aura = 100 * window.game.cave.level;
    
    window.game.updateCaveDisplay();
    window.game.updateUI();
    
    // æ›´æ–°æˆ¿é–“é¡¯ç¤º
    const roomDiv = event.currentTarget.parentElement;
    roomDiv.querySelector('.room-level').textContent = `Lv.${room.level}`;
    event.currentTarget.textContent = `å‡ç´š (${room.upgradeCost}ğŸ’)`;
}

// å•Ÿå‹•éŠæˆ²
window.game = new MultiSwordGame();
window.addEventListener('DOMContentLoaded', () => {
    game.init();
});

// é˜²æ­¢è§¸æ‘¸æ»¾å‹•å’Œç¸®æ”¾
document.addEventListener('touchmove', (e) => {
    e.preventDefault();
}, { passive: false });

document.addEventListener('gesturestart', (e) => {
    e.preventDefault();
});

// é˜²æ­¢é›™æ“Šç¸®æ”¾
let lastTouchEnd = 0;
document.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) {
        e.preventDefault();
    }
    lastTouchEnd = now;
}, false);
    </script>
    <!-- ===== ç™»å½•ä¸å­˜æ¡£ï¼ˆæ— èƒŒæ™¯éŸ³ä¹ï¼Œä¿ç•™èƒŒæ™¯å›¾/ç‚¹å‡»éŸ³æ•ˆï¼‰ ===== -->
<style>
  .login-mask{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:9999;
    background:#0b0b14 url('./background_mountain.png') center/cover no-repeat}
  .login-card{width:min(92vw,420px);background:rgba(0,0,0,.72);border:1px solid #2b2b3a;border-radius:14px;
    padding:28px;color:#eaeaf2;box-shadow:0 10px 30px rgba(0,0,0,.35)}
  .login-title{margin:0 0 6px;font-size:24px;color:#ffd54a}
  .login-sub{margin:0 0 20px;color:#cfd3dc}
  .row{margin-bottom:14px}
  .row label{display:block;margin:0 0 6px;color:#b8bdc7;font-size:14px}
  .row input{width:100%;padding:12px 14px;border-radius:10px;border:1px solid #34344a;background:#171724;color:#eaeaf2}
  .btn{width:100%;padding:12px 14px;border:none;border-radius:10px;color:#0b0b14;font-weight:700;cursor:pointer;background:#ffd54a}
  .btn.secondary{background:#5865f2;color:#fff;margin-top:8px}
  .opts{display:flex;justify-content:space-between;align-items:center;margin-top:10px;font-size:13px;color:#b8bdc7}
  .user-list{margin-top:10px;display:none}
  .user-item{display:flex;justify-content:space-between;align-items:center;background:#19192a;border:1px solid #2e2e44;
    padding:8px 10px;border-radius:8px;margin-bottom:8px}
  .logout-btn{position:fixed;top:10px;right:10px;z-index:9998;padding:8px 12px;border-radius:8px;border:1px solid #2b2b3a;background:#171724;color:#eaeaf2;display:none}
  .save-tip{position:fixed;bottom:10px;right:10px;background:#171724;border:1px solid #2b2b3a;color:#b8bdc7;padding:6px 10px;border-radius:8px;display:none}
</style>

<div id="loginMask" class="login-mask">
  <div class="login-card">
    <h1 class="login-title">å‡¡äººä¿®ä»™ä¼ </h1>
    <p class="login-sub">ç™»å½•ä»¥åŠ è½½/åˆ›å»ºæœ¬åœ°å­˜æ¡£</p>

    <form id="loginForm" onsubmit="return handleLogin(event)">
      <div class="row">
        <label>é“å·</label>
        <input id="username" name="username" required placeholder="è¯·è¾“å…¥é“å·" autocomplete="username">
      </div>
      <div class="row">
        <label>ç¬¦å¯†ç </label>
        <input id="password" name="password" type="password" required placeholder="è¯·è¾“å…¥å¯†ç " autocomplete="current-password">
      </div>
      <button class="btn" type="submit" onclick="playClick()">è¿›å…¥ä¿®ä»™ç•Œ</button>
    </form>

    <button class="btn secondary" onclick="guestLogin();playClick()">æ¸¸å®¢è¯•ç©</button>

    <div class="opts">
      <label><input id="rememberMe" type="checkbox"> è®°ä½é“å·</label>
      <a href="javascript:void(0)" onclick="toggleUserList();playClick()">é€‰æ‹©è´¦å·</a>
    </div>

    <div id="userList" class="user-list"></div>
  </div>
</div>

<button class="logout-btn" onclick="logout();playClick()">é€€å‡ºç™»å½•</button>
<div class="save-tip" id="saveTip">â€”</div>

<audio id="sfxClick" src="./click.mp3"></audio>

<script>
/* ===== æ•°æ®ä¸å·¥å…· ===== */
 const LS_USERS = 'xiuxian_users';
  const API_BASE = 'https://xiuxiangame.onrender.com';

  async function cloudSave(user, secret, data) {
    try {
      const res = await fetch(`${API_BASE}/api/save`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ user, secret, data })
      });
      return await res.json();
    } catch (err) {
      console.warn('Save failed:', err);
      return { ok: false };
    }
  }

  async function cloudLoad(user, secret) {
    try {
      const res = await fetch(
        `${API_BASE}/api/load?user=${encodeURIComponent(user)}&secret=${encodeURIComponent(secret)}`
      );
      return await res.json();
    } catch (err) {
      console.warn('Load failed:', err);
      return null;
    }
  }
  // ====== è´¦å·ä¸äº‘å­˜æ¡£èƒ¶æ°´å±‚ ======



// ä½ æ¸¸æˆé‡Œçš„çŠ¶æ€å¯¼å‡º/å¯¼å…¥æ–¹æ³•ï¼ˆæŒ‰ä½ çš„å®é™…å‡½æ•°æ›¿æ¢ï¼‰
function exportGameState() {
  // TODO: ç”¨ä½ ç°æœ‰çš„å¯¼å‡ºæ–¹æ³•æ›¿æ¢ï¼Œæ¯”å¦‚ window.gameState / getSaveData()
  return window.gameState || {};
}
function importGameState(data) {
  // TODO: ç”¨ä½ ç°æœ‰çš„å¯¼å…¥æ–¹æ³•æ›¿æ¢ï¼Œæ¯”å¦‚ setSaveData(data)
  if (data && typeof data === 'object') {
    window.gameState = data;
  }
}

// ç»‘å®š UI
const $user   = document.getElementById('userInput');
const $secret = document.getElementById('secretInput');
const $btnLogin = document.getElementById('btnLogin');
const $btnSave  = document.getElementById('btnSave');

// æ¢å¤ä¸Šæ¬¡è´¦å·/å¯†é’¥
(function restoreCreds() {
  try {
    const u = localStorage.getItem(LS_USER) || '';
    const LS_USERS  = 'xiuxian_users';
    const s = localStorage.getItem(LS_SECRET) || '';
    if ($user)   $user.value = u;
    if ($secret) $secret.value = s;
  } catch (e) {}
})();

// ç™»å½•=äº‘åŠ è½½
async function handleLogin() {
  const user   = ($user?.value || '').trim();
  const secret = ($secret?.value || '').trim();
  if (!user || !secret) { alert('è¯·å¡«å†™ã€é“å·ã€‘ä¸ã€ç¬¦å¯†ç ã€‘'); return; }

  // è®°ä½å‡­è¯
  try {
    localStorage.setItem(LS_USER, user);
    localStorage.setItem(LS_SECRET, secret);
  } catch (e) {}

  // æ‹‰å–äº‘ç«¯å­˜æ¡£
  try {
    const data = await cloudLoad(user, secret);
    if (data) {
      if (typeof importGameState === 'function') importGameState(data);
      _writeLocalMirror(user, data);
      console.log('[cloud] load ok:', data);
      alert('äº‘å­˜æ¡£åŠ è½½æˆåŠŸï¼');
      // TODO: enterGame();
    } else {
      console.log('[cloud] no data yet, start new');
      alert('äº‘ç«¯æš‚æ— å­˜æ¡£ï¼Œå°†ä»æ–°æ¡£å¼€å§‹ã€‚');
    }
  } catch (err) {
    console.warn('[cloud] load failed', err);
    alert('äº‘å­˜æ¡£åŠ è½½å¤±è´¥ï¼Œè¯·ç¨åå†è¯•');
  }
}

// ä¸€é”®ä¿å­˜
async function handleSave() {
  const user   = ($user?.value || '').trim() || localStorage.getItem(LS_USER);
  const secret = ($secret?.value || '').trim() || localStorage.getItem(LS_SECRET);
  if (!user || !secret) { alert('å°šæœªç™»å½•ï¼ˆéœ€è¦é“å·ä¸ç¬¦å¯†ç ï¼‰'); return; }

  const data = (typeof exportGameState === 'function') ? exportGameState() : null;
  if (!data) { alert('æ²¡æœ‰å¯ä¿å­˜çš„æ•°æ®'); return; }

  try {
    const r = await cloudSave(user, secret, data);
    if (r?.ok) {
      console.log('[cloud] save ok', r);
      alert('å·²ä¿å­˜åˆ°äº‘ç«¯');
    } else {
      throw new Error('bad response');
    }
  } catch (err) {
    console.warn('[cloud] save failed', err);
    alert('ä¿å­˜å¤±è´¥ï¼Œè¯·ç¨åå†è¯•');
  }
}

// äº‹ä»¶ç»‘å®š
$btnLogin?.addEventListener('click', handleLogin);
$btnSave?.addEventListener('click', handleSave);

// å¦‚æœä½ å¸Œæœ›åœ¨æ§åˆ¶å°ä¹Ÿèƒ½ç›´æ¥è°ƒè¯•ï¼š
window.cloudSave = cloudSave;
window.cloudLoad = cloudLoad;
// â€”â€” æœ¬åœ°é•œåƒè¾…åŠ©ï¼šæŠŠäº‘å­˜æ¡£å†™å›è€çš„æœ¬åœ°ç»“æ„ï¼ˆä¾›æ—§é€»è¾‘ç»§ç»­ä½¿ç”¨ï¼‰ â€”â€”
// æ—§ä»£ç é‡Œç”¨çš„â€œæ‰€æœ‰ç”¨æˆ·å­˜æ¡£â€çš„é”®
function writeLocalMirror(user, data) {
  try {
    const users = JSON.parse(localStorage.getItem(LS_USERS) || '{}');
    users[user] = data || {};
    localStorage.setItem(LS_USERS, JSON.stringify(users));
  } catch {}
}
function readLocal(user) {
  try {
    const users = JSON.parse(localStorage.getItem(LS_USERS) || '{}');
    return users[user] || null;
  } catch { return null; }
}

// â€”â€” å¯åŠ¨ä¼˜å…ˆè¯»å–äº‘ç«¯ï¼›è‹¥äº‘ç«¯æ—  -> ç”¨æœ¬åœ°ï¼›è‹¥æœ¬åœ°æœ‰è€Œäº‘ç«¯æ—  -> è¿ç§»åˆ°äº‘ç«¯ â€”â€”
(async function bootWithCloudPriority(){
  const user   = localStorage.getItem('xiuxian_user')   || prompt('è¾“å…¥é“å·ï¼ˆuserï¼‰ï¼š');
  const secret = localStorage.getItem('xiuxian_secret') || prompt('è¾“å…¥ç¬¦å¯†ç ï¼ˆsecretï¼‰ï¼š');
  if (!user || !secret) return;
  localStorage.setItem('xiuxian_user', user);
  localStorage.setItem('xiuxian_secret', secret);

  let cloud = null;
  try { cloud = await cloudLoad(user, secret); } catch {}

  if (cloud && typeof importGameState === 'function') {
    importGameState(cloud);        // ç”¨äº‘çš„
    writeLocalMirror(user, cloud); // åŒæ­¥å›æœ¬åœ°ï¼Œæ—§é€»è¾‘å¯è¯»
    console.log('[cloud] loaded & mirrored to local');
  } else {
    const local = readLocal(user); // äº‘æ²¡æœ‰å°±çœ‹æœ¬åœ°æœ‰æ²¡æœ‰
    if (local) {
      // æœ¬åœ° -> äº‘ç«¯ï¼ˆé¦–ç™»è¿ç§»ï¼‰
      try {
        await cloudSave(user, secret, local);
        console.log('[cloud] migrated local -> cloud');
      } catch {}
      if (typeof importGameState === 'function') importGameState(local);
    } else {
      console.log('[cloud] no cloud, no local: start fresh');
    }
  }
})();

// â€”â€” æ¯æ¬¡ä¿å­˜åŒæ—¶å†™äº‘ç«¯ä¸æœ¬åœ°ï¼ˆä¿è¯ä¸¤è¾¹ä¸€è‡´ï¼‰ â€”â€”
async function saveBoth() {
  const user   = localStorage.getItem('xiuxian_user');
  const secret = localStorage.getItem('xiuxian_secret');
  if (!user || !secret || typeof exportGameState !== 'function') return;
  const data = exportGameState();
  writeLocalMirror(user, data);         // æœ¬åœ°é•œåƒ
  try { await cloudSave(user, secret, data); } catch {}
  console.log('[cloud] saved both');
}

// ä½ åŸæ¥çš„ä¿å­˜æŒ‰é’®å¯ä»¥ç›´æ¥æ”¹ä¸ºï¼š$btnSave?.addEventListener('click', saveBoth);

// â€”â€” å…œåº•ï¼šå®šæ—¶ä¸ç¦»å¼€æ—¶ä¹ŸåŒæ­¥åˆ°äº‘ + æœ¬åœ° â€”â€”
setInterval(saveBoth, 60_000);
window.addEventListener('beforeunload', () => {
  try {
    const user   = localStorage.getItem('xiuxian_user');
    const secret = localStorage.getItem('xiuxian_secret');
    if (!user || !secret || typeof exportGameState !== 'function') return;
    const data = exportGameState();
    writeLocalMirror(user, data);
    const payload = JSON.stringify({ user, secret, data });
    navigator.sendBeacon(`${API_BASE}/api/save`, new Blob([payload], { type: 'application/json' }));
  } catch {}
});
// ===== è‡ªåŠ¨äº‘å­˜æ¡£ï¼ˆè·¨è®¾å¤‡ï¼‰ =====
const LS_USER   = 'xiuxian_user';
const LS_SECRET = 'xiuxian_secret';
function _writeLocalMirror(user, data) {
  try {
    const users = JSON.parse(localStorage.getItem(LS_USERS)) || {};
    users[user] = data || {};
    localStorage.setItem(LS_USERS, JSON.stringify(users));
  } catch (e) {
    console.warn("å†™å…¥æœ¬åœ°é•œåƒå¤±è´¥", e);
  }
}
// ===== æœ¬åœ°é•œåƒå·¥å…·ï¼ˆç”¨äºå…¼å®¹ä½ åŸæ¥çš„æœ¬åœ°å­˜æ¡£ç»“æ„ï¼‰ =====

function _writeLocalMirror(user, data) {
  try {
    const map = JSON.parse(localStorage.getItem(LS_USERS) || '{}');
    map[user] = data || {};
    localStorage.setItem(LS_USERS, JSON.stringify(map));
  } catch (e) {}
}

function readLocal(user) {
  try {
    const map = JSON.parse(localStorage.getItem(LS_USERS) || '{}');
    return map[user] || null;
  } catch (e) {
    return null;
  }
}
// å¯åŠ¨è‡ªåŠ¨åŠ è½½ï¼ˆå¦‚æœæœ¬åœ°å·²ç»å­˜è¿‡è´¦å·+å¯†é’¥ï¼‰
(async function autoCloudBoot() {
  try {
    const u = localStorage.getItem(LS_USER) || '';
    const s = localStorage.getItem(LS_SECRET) || '';
    if (!u || !s) return;

    const data = await cloudLoad(u, s);
    if (data && typeof importGameState === 'function') {
      importGameState(data);
      _writeLocalMirror(u, data);
      console.log('[cloud] auto load ok:', data);
    }
  } catch (err) {
    console.warn('[cloud] auto load failed:', err);
  }
})();

// æ¯ 60s è‡ªåŠ¨ä¿å­˜ä¸€æ¬¡ï¼ˆç¡®ä¿æ•´ç«™ä»…æ­¤ä¸€å¤„ setIntervalï¼‰
const SAVE_INTERVAL_MS = 60_000;
setInterval(async () => {
  try {
    const u = localStorage.getItem(LS_USER) || '';
    const s = localStorage.getItem(LS_SECRET) || '';
    if (!u || !s) return;

    const data = (typeof exportGameState === 'function') ? exportGameState() : null;
    if (!data) return;

    const r = await cloudSave(u, s, data);
    if (!r || !r.ok) throw new Error('save not ok');
    console.log('[cloud] auto save ok:', r.updatedAt);
  } catch (err) {
    console.warn('[cloud] auto save failed:', err);
  }
}, SAVE_INTERVAL_MS);

// å…³é—­é¡µé¢å…œåº•ä¿å­˜ï¼ˆsendBeaconï¼‰â€”â€”åªä¿ç•™è¿™ä¸€ä»½
window.addEventListener('beforeunload', () => {
  try {
    const u = localStorage.getItem(LS_USER) || '';
    const s = localStorage.getItem(LS_SECRET) || '';
    if (!u || !s) return;

    const data = (typeof exportGameState === 'function') ? exportGameState() : null;
    if (!data) return;

    const url = `${API_BASE}/api/save`;
    const payload = JSON.stringify({ user: u, secret: s, data });
    navigator.sendBeacon(url, new Blob([payload], { type: 'application/json' }));
  } catch {}
});
let users = JSON.parse(localStorage.getItem(LS_USERS) || '{}');
let currentUser = null;
let gameState = null;

const tip = m => { 
    const t = document.getElementById('saveTip'); 
    if(t) {
        t.textContent = m; 
        t.style.display = 'block'; 
        setTimeout(() => t.style.display = 'none', 1500); 
    }
};
const playClick = () => document.getElementById('sfxClick')?.play().catch(() => {});

/* ===== å­˜æ¡£ç³»ç»Ÿ ===== */
function saveUsers() { 
    try {
        localStorage.setItem(LS_USERS, JSON.stringify(users)); 
        return true;
    } catch(e) {
        console.error('ä¿å­˜ç”¨æˆ·æ•°æ®å¤±è´¥:', e);
        if(e.name === 'QuotaExceededError') {
            tip('âš ï¸ å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œè¯·æ¸…ç†æµè§ˆå™¨ç¼“å­˜');
        }
        return false;
    }
}

function saveGame() { 
    if(!currentUser || !users[currentUser] || !window.game) {
        return false;
    }
    
    try {
        // ä¿å­˜å®Œæ•´æ¸¸æˆæ•°æ®
        const fullGameData = {
            // ç©å®¶æ•°æ®
            player: {
                x: window.game.player.x,
                y: window.game.player.y,
                worldX: window.game.player.worldX,
                worldY: window.game.player.worldY,
                mana: window.game.player.mana,
                maxMana: window.game.player.maxMana,
                spiritual: window.game.player.spiritual,
                maxSpiritual: window.game.player.maxSpiritual,
                shield: window.game.player.shield,
                maxShield: window.game.player.maxShield,
                shieldDamageReduction: window.game.player.shieldDamageReduction,
                attack: window.game.player.attack,
                defense: window.game.player.defense,
                realm: window.game.player.realm,
                lingshi: window.game.player.lingshi
            },
            // æŠ€èƒ½æ•°æ® - ä½¿ç”¨å®‰å…¨çš„æ·±æ‹·è´
            skills: JSON.parse(JSON.stringify(window.game.skills || {})),
            // å‚¨ç‰©ç³»ç»Ÿ
            storage: JSON.parse(JSON.stringify(window.game.storage || {})),
            // ç‚¼ä¸¹ç³»ç»Ÿ
            alchemy: JSON.parse(JSON.stringify(window.game.alchemy || {})),
            // é”»é€ ç³»ç»Ÿ
            forge: JSON.parse(JSON.stringify(window.game.forge || {})),
            // æ´åºœç³»ç»Ÿ  
            cave: JSON.parse(JSON.stringify(window.game.cave || {})),
            // å…¶ä»–
            musicEnabled: window.game.musicEnabled,
            lastSave: Date.now(),
            username: currentUser,
            version: '1.0' // æ·»åŠ ç‰ˆæœ¬å·ä»¥ä¾¿æœªæ¥å…¼å®¹æ€§å¤„ç†
        };
        
        users[currentUser].gameData = fullGameData;

        // â¬‡ï¸ æ–°å¢ï¼šåŒæ­¥åˆ°åç«¯
        cloudSave(currentUser, fullGameData);
        
        if(saveUsers()) {
            tip(`ğŸ’¾ è‡ªåŠ¨ä¿å­˜æˆåŠŸ [${new Date().toLocaleTimeString()}]`);
            return true;
        }
        return false;
        
    } catch(e) {
        console.error('ä¿å­˜æ¸¸æˆå¤±è´¥:', e);
        tip('âš ï¸ ä¿å­˜å¤±è´¥ï¼Œè¯·é‡è¯•');
        return false;
    }
}

function loadGame(data) {
    if(!data || !window.game) return false;
    
    try {
        // ç‰ˆæœ¬å…¼å®¹æ€§æ£€æŸ¥
        const version = data.version || '0.9';
        if(version !== '1.0') {
            console.log('å­˜æ¡£ç‰ˆæœ¬ä¸åŒï¼Œå°è¯•å…¼å®¹åŠ è½½');
        }
        
        // åŠ è½½ç©å®¶æ•°æ®
        if(data.player) {
            Object.assign(window.game.player, data.player);
        }
        
        // åŠ è½½æŠ€èƒ½æ•°æ®
        if(data.skills) {
            window.game.skills = {...window.game.skills, ...data.skills};
        }
        
        // åŠ è½½å‚¨ç‰©ç³»ç»Ÿ
        if(data.storage) {
            window.game.storage = {...window.game.storage, ...data.storage};
        }
        
        // åŠ è½½ç‚¼ä¸¹ç³»ç»Ÿ
        if(data.alchemy) {
            window.game.alchemy = {...window.game.alchemy, ...data.alchemy};
        }
        
        // åŠ è½½é”»é€ ç³»ç»Ÿ
        if(data.forge) {
            window.game.forge = {...window.game.forge, ...data.forge};
        }
        
        // åŠ è½½æ´åºœç³»ç»Ÿ
        if(data.cave) {
            window.game.cave = {...window.game.cave, ...data.cave};
        }
        
        // åŠ è½½å…¶ä»–è®¾ç½®
        if(data.musicEnabled !== undefined) {
            window.game.musicEnabled = data.musicEnabled;
        }
        
        // æ›´æ–°UI
        if(window.game.updateUI) window.game.updateUI();
        if(window.game.updateSpellMenu) window.game.updateSpellMenu();
        if(window.game.initStorage) window.game.initStorage();
        
        // æ›´æ–°å¢ƒç•Œæ˜¾ç¤º
        const realms = [
            'ç…‰æ°£æœŸä¸€å±¤', 'ç…‰æ°£æœŸäºŒå±¤', 'ç…‰æ°£æœŸä¸‰å±¤',
            'ç…‰æ°£æœŸå››å±¤', 'ç…‰æ°£æœŸäº”å±¤', 'ç…‰æ°£æœŸå…­å±¤',
            'ç¯‰åŸºæœŸå‰æœŸ', 'ç¯‰åŸºæœŸä¸­æœŸ', 'ç¯‰åŸºæœŸå¾ŒæœŸ',
            'é‡‘ä¸¹æœŸ', 'å…ƒå¬°æœŸ', 'åŒ–ç¥æœŸ'
        ];
        const realmBadge = document.getElementById('realmBadge');
        if(realmBadge) {
            realmBadge.textContent = realms[window.game.player.realm] || 'é£›å‡å¢ƒ';
        }
        
        if(window.game.addLog) {
            window.game.addLog(`å­˜æ¡£è½½å…¥æˆåŠŸï¼æ¬¢è¿å›æ¥ï¼Œ${data.username || 'é“å‹'}`, 'system');
            const lastSaveTime = data.lastSave ? new Date(data.lastSave).toLocaleString() : 'æœªçŸ¥';
            window.game.addLog(`ä¸Šæ¬¡ä¿å­˜æ—¶é—´ï¼š${lastSaveTime}`, 'system');
        }
        
        return true;
        
    } catch(e) {
        console.error('åŠ è½½å­˜æ¡£å¤±è´¥:', e);
        if(window.game?.addLog) {
            window.game.addLog('å­˜æ¡£åŠ è½½å‡ºç°é—®é¢˜ï¼Œä½¿ç”¨é»˜è®¤æ•°æ®', 'system');
        }
        return false;
    }
}

// è‡ªåŠ¨ä¿å­˜ - æ¯30ç§’
let autoSaveInterval = setInterval(() => { 
    if(currentUser && window.game) {
        saveGame(); 
    }
}, 30000);

// ç¦»å¼€é¡µé¢æ—¶ä¿å­˜
window.addEventListener('beforeunload', (e) => {
    if(currentUser && window.game) {
        saveGame();
    }
});

// æ¸…ç†å‡½æ•°ï¼ˆå¯é€‰ï¼‰
function clearAutoSave() {
    if(autoSaveInterval) {
        clearInterval(autoSaveInterval);
        autoSaveInterval = null;
    }
}

/* ===== ç™»å½• / æ¸¸å®¢ / é€€å‡º ===== */
function handleLogin(e){
  e.preventDefault();
  const fd = new FormData(document.getElementById('loginForm'));
  const u = (fd.get('username')||'').toString().trim();
  const p = (fd.get('password')||'').toString();
  if(!u || !p) return alert('è¯·è¾“å…¥é“å·ä¸å¯†ç ');

  if(!users[u]) users[u] = { password:p, gameData: { ...gameState, username:u }, createTime:Date.now() };
  else if(users[u].password !== p) return alert('å¯†ç é”™è¯¯');

  currentUser = u;
  gameState = users[u].gameData || { ...gameState, username:u };
  if(document.getElementById('rememberMe').checked) localStorage.setItem('rememberedUser', u);
  enterGameSafe();
  cloudLoad(u).then(d => { 
    if (d) loadGame(d);
  });
  const bgm = document.getElementById('bgmMain');
  if (bgm) {
    bgm.play().catch(err => console.log("éŸ³ä¹æœªèƒ½æ’­æ”¾ï¼š", err));
    }
  if (users[u]?.gameData) {
    loadGame(users[u].gameData);
    }
  return false;
}

function guestLogin(){
  const u = 'Guest_' + Math.floor(Math.random()*10000);
  if (!users[u]) users[u] = { password: '', gameData: null, createTime: Date.now() };
  currentUser = u;
  gameState = { ...(gameState||{}), username: u };
  enterGameSafe();
}

function logout(){
  saveGame();
  currentUser = null;
  document.querySelector('.logout-btn').style.display='none';
  document.getElementById('loginMask').style.display='flex';
}

/* ===== è´¦å·åˆ—è¡¨ ===== */
function toggleUserList(){
  const box = document.getElementById('userList');
  if(box.style.display==='block'){ box.style.display='none'; return; }
  box.innerHTML = '';
  const names = Object.keys(users);
  if(names.length===0){ box.innerHTML='<div style="color:#9aa0aa">æš‚æ— è´¦å·</div>'; box.style.display='block'; return; }
  names.forEach(n=>{
    const w=document.createElement('div'); w.className='user-item';
    w.innerHTML = `<div><div style="font-weight:700">${n}</div>
                   <div style="font-size:12px;color:#9aa0aa">å¢ƒç•Œï¼š${users[n].gameData?.realm||1} å±‚</div></div>
                   <div><button onclick="quickLogin('${n}')">ç™»å½•</button>
                   <button onclick="delUser('${n}')">åˆ é™¤</button></div>`;
    box.appendChild(w);
  });
  box.style.display='block';
}
function quickLogin(name){
  const p = prompt('è¯·è¾“å…¥å¯†ç '); if(!p) return;
  if(users[name]?.password === p){ currentUser=name; gameState=users[name].gameData; enterGameSafe(); }
  else alert('å¯†ç é”™è¯¯');
}
function delUser(name){ if(confirm(`ç¡®å®šåˆ é™¤ã€Œ${name}ã€ï¼Ÿ`)){ delete users[name]; saveUsers(); toggleUserList(); toggleUserList(); } }

/* ===== è¿›å…¥æ¸¸æˆï¼ˆç¨³å®šç‰ˆï¼‰ ===== */
function enterGameSafe(){
  document.getElementById('loginMask').style.display='none';
  document.querySelector('.logout-btn').style.display='inline-block';
  try{ saveUsers(); }catch{}
  if (currentUser) {
  cloudLoad(currentUser)
    .then(d => {
      if (d) {
        loadGame(d);                 // å…ˆç”¨äº‘ç«¯
      } else if (users[currentUser]?.gameData) {
        loadGame(users[currentUser].gameData); // æ²¡æœ‰â†’ç”¨æœ¬åœ°
      }
    })
    .catch(err => {
      console.warn("äº‘ç«¯è¯»å–å¤±è´¥ï¼Œæ”¹ç”¨æœ¬åœ°ï¼š", err);
      if (users[currentUser]?.gameData) {
        loadGame(users[currentUser].gameData);
      }
    });
}

  if(typeof window.initAfterLogin === 'function'){ try{ initAfterLogin(gameState); }catch(e){ console.error(e); } }
  else {
    let c=document.getElementById('gameCanvas');
    if(!c){ c=document.createElement('canvas'); c.id='gameCanvas'; c.width=innerWidth; c.height=innerHeight; document.body.appendChild(c); }
    const ctx=c.getContext('2d'); ctx.fillStyle='#223'; ctx.fillRect(0,0,c.width,c.height);
    ctx.fillStyle='#0f0'; ctx.font='24px sans-serif'; ctx.fillText('ç™»å½•æˆåŠŸï¼š'+(gameState.username||''), 20, 40);
  }
}

/* ===== ç™»å½•ç•Œé¢é”®ç›˜å±è”½ï¼Œé˜²æ­¢æ¸¸æˆçƒ­é”®å¹²æ‰° ===== */
window.addEventListener('keydown', function keyBlocker(e){
  if(document.getElementById('loginMask')?.style.display!=='none'){ e.stopImmediatePropagation(); }
  else window.removeEventListener('keydown', keyBlocker, true);
}, true);

/* ===== åˆå§‹åŒ–ï¼šå¡«å……è®°ä½çš„é“å· ===== */
document.addEventListener('DOMContentLoaded', ()=>{
  const remembered = localStorage.getItem('rememberedUser');
  if(remembered){ document.getElementById('username').value = remembered; document.getElementById('rememberMe').checked = true; }
});
</script>
</body>
</html>